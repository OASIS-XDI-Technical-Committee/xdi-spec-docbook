<?xml version="1.0" encoding="UTF-8"?>
<!-- 
For use when a committee document points at the OASIS web site for publishing:
<?xml-stylesheet type="text/xsl" 
href="http://docs.oasis-open.org/templates/DocBook/spec-0.6/stylesheets/oasis-specification-html.xsl"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
         "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" 

For use when a committee document points to an embedded runtime installation:
<?xml-stylesheet type="text/xsl" 
         href="htmlruntime/spec-0.6/stylesheets/oasis-specification-html.xsl"?>
<!DOCTYPE article
 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
        "htmlruntime/spec-0.6/docbook/docbookx.dtd" 

For use when a committee document is published in a local environment only
(note the instructions for local publishing require adjusting the stylesheet
 and DocBook directories in these declarations):
<?xml-stylesheet type="text/xsl" 
href="file:///c:/oasis/spec-0.6/stylesheets/oasis-specification-html-offline.xsl"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
         "file:///c:/oasis/spec-0.6/docbook/docbookx.dtd" 
-->
<?xml-stylesheet type="text/xsl" 
         href="../../htmlruntime/spec-0.6/stylesheets/oasis-specification-html.xsl"?>
<!DOCTYPE article
 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
        "../../htmlruntime/spec-0.6/docbook/docbookx.dtd" 
[
<!--the document properties-->
<!ENTITY name "xdi-messaging">
<!ENTITY pversion "0.1">
<!ENTITY version "1.0">
<!ENTITY stage "wd05">
<!ENTITY standard "Working Draft 05">
<!ENTITY this-loc "http://docs.oasis-open.org/xdi/spec-&version;">
<!ENTITY previous-loc "http://docs.oasis-open.org/xdi/spec-&pversion;">
<!ENTITY latest-loc "http://docs.oasis-open.org/xdi/spec">
<!ENTITY pubdate "(not published)">
<!ENTITY title "XDI Messaging V&version;">
]>

<article status="&standard;">

<articleinfo>

<title>&title;</title>
<productname>&name;</productname>
<productnumber>&version;-&stage;</productnumber>
<releaseinfo role="track">Standards Track Work Product</releaseinfo>
<releaseinfo role="OASIS-specification-this-authoritative">&this-loc;/&name;-&version;-&stage;.xml</releaseinfo>
<releaseinfo role="OASIS-specification-this">&this-loc;/&name;-&version;-&stage;.pdf</releaseinfo>
<releaseinfo role="OASIS-specification-this">&this-loc;/&name;-&version;-&stage;.html</releaseinfo>
<releaseinfo role="OASIS-specification-previous-authoritative">&previous-loc;/&name;-&pversion;.xml</releaseinfo>
<releaseinfo role="OASIS-specification-previous">&previous-loc;/&name;-&pversion;.pdf</releaseinfo>
<releaseinfo role="OASIS-specification-previous">&previous-loc;/&name;-&pversion;.html</releaseinfo>
<releaseinfo role="OASIS-specification-latest-authoritative">&latest-loc;/&name;.xml</releaseinfo>
<releaseinfo role="OASIS-specification-latest">&latest-loc;/&name;.pdf</releaseinfo>
<releaseinfo role="OASIS-specification-latest">&latest-loc;/&name;.html</releaseinfo>
<releaseinfo role="committee"><ulink url="http://www.oasis-open.org/committees/xdi">OASIS XDI TC</ulink></releaseinfo>
<authorgroup>
  <editor> <firstname>Markus</firstname><surname>Sabadello</surname>
    <affiliation><orgname>Danube Tech</orgname></affiliation>
    <email>markus@danubetech.com</email> </editor>
  <editor> <firstname>Drummond</firstname><surname>Reed</surname>
    <affiliation><orgname>XDI.org</orgname></affiliation>
    <email>drummond.reed@xdi.org</email> </editor>
</authorgroup>
<pubdate>&pubdate;</pubdate>
<copyright><year>2015</year>
<holder>OASIS Open, Inc. All Rights Reserved.</holder></copyright>
 <legalnotice role="additional"><title>Additional artifacts</title>
 <para>This prose specification is one component of a Work Product which also includes:</para>
 <!--itemizedlist spacing="compact"> <listitem><para>
publishing materials: <ulink url="&this-loc;/&name;-&version;-&stage;.zip">&this-loc;/&name;-&version;-&stage;.zip</ulink></para>
 </listitem> </itemizedlist-->
</legalnotice>
<legalnotice role="related"><title>Related work</title>
  <para>This document is primarily based on a set of proposals that had been collected by the OASIS XDI TC on its associated wiki at <ulink url="https://wiki.oasis-open.org/xdi/">https://wiki.oasis-open.org/xdi/</ulink>.</para>
</legalnotice>

<abstract><title>Abstract</title>
  <para>This working draft is for reviewer comment only and is not yet a standards document or published at OASIS. This specification defines the abstract pattern for transmitting XDI messages between peers.</para>
</abstract>

<legalnotice role="citation"><title>Citation format</title>
<para>When referencing this specification the following citation format should be used:</para>
<bibliolist> <bibliomixed>
  <abbrev>OASIS-XDI-Messaging-V1.0</abbrev>
  <title>OASIS XDI Messaging V1.0</title>
  <date>&pubdate;. </date>
  <releaseinfo>OASIS &standard;. </releaseinfo>
  <citetitle><ulink url="&latest-loc;/&name;.html">&latest-loc;/&name;.html</ulink>.</citetitle>
</bibliomixed> </bibliolist>
</legalnotice>
<legalnotice role="notices"><title>Notices</title>
<para>Copyright &#169; OASIS&#174; Open 2015. All Rights Reserved.  </para>
<para>All capitalized terms in the following text have the meanings assigned to them in the OASIS Intellectual Property Rights Policy (the "OASIS IPR Policy"). The full Policy may be found at <ulink  url="http://www.oasis-open.org/who/intellectualproperty.php">http://www.oasis-open.org/who/intellectualproperty.php</ulink>.</para>
<para>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to OASIS, except as needed for the purpose of developing any document or deliverable produced by an OASIS Technical Committee (in which case the rules applicable to copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate it into languages other than English.</para> 
<para>The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns.</para>
<para>This document and the information contained herein is provided on an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</para> 
<para>OASIS requests that any OASIS Party or any other party that believes it has patent claims that would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification.</para>
<para>OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of ownership of any patent claims that would necessarily be infringed by implementations of this specification by a patent holder that is not willing to provide a license to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification. OASIS may include such claims on its website, but disclaims any obligation to do so.</para>
<para>OASIS takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS' procedures with respect to rights in any document or deliverable produced by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be obtained from the OASIS TC Administrator. OASIS makes no representation that any information or list of intellectual property rights will at any time be complete, or that any claims in such list are, in fact, Essential Claims.</para>
<para>The name "OASIS" is a trademark of <ulink url="http://www.oasis-open.org">OASIS</ulink>, the owner and developer of this specification, and should be used only to refer to the organization and its official outputs. OASIS welcomes reference to, and implementation and use of, specifications, while reserving the right to enforce its marks against misleading uses. Please see <ulink url="http://www.oasis-open.org/who/trademark.php">http://www.oasis-open.org/who/trademark.php</ulink> for above guidance.</para>
</legalnotice>

</articleinfo>

<section id="s.introduction"><title>Introduction</title>

  <para>This specification defines the abstract pattern for transmitting XDI messages between peers.</para>
  <para>This builds on the basic XDI graph model (see <xref linkend="xdi-core-1.0"/>).</para>

  <section><title> Key words</title>

    <para>The key words <glossterm>must</glossterm>, <glossterm>must not</glossterm>, <glossterm>required</glossterm>,
      <glossterm>shall</glossterm>, <glossterm>shall not</glossterm>, <glossterm>should</glossterm>, <glossterm>should not</glossterm>,
      <glossterm>recommended</glossterm>, <glossterm>may</glossterm>, and <glossterm>optional</glossterm> are to be
      interpreted as described in <xref linkend="rfc2119"/>. Note that for reasons of style, these words are not capitalized in this
      document.</para>

  </section>
  
  <section><title>Normative References</title>

    <bibliolist> <bibliomixed id="xdi-core-1.0">
      <abbrev>OASIS-XDI-Core-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-core-1.0/xdi-core-1.0-wd01.xml">OASIS XDI 1.0 Core Specification</ulink></title>
      <author><firstname>Joseph </firstname> <surname>Boyle</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>. 
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-core.html">&latest-loc;/xdi-core.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-discovery-1.0">
      <abbrev>OASIS-XDI-Discovery-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-discovery-1.0/xdi-discovery-1.0-wd01.xml">OASIS XDI 1.0 Discovery Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-discovery.html">&latest-loc;/xdi-discovery.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-bindings-1.0">
      <abbrev>OASIS-XDI-Bindings-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-bindings-1.0/xdi-bindings-1.0-wd01.xml">OASIS XDI 1.0 Bindings Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-bindings.html">&latest-loc;/xdi-bindings.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-connections-1.0">
      <abbrev>OASIS-XDI-Connections-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-connections-1.0/xdi-connections-1.0-wd01.xml">OASIS XDI 1.0 Connections Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-connections.html">&latest-loc;/xdi-connections.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-push-1.0">
      <abbrev>OASIS-XDI-Push-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-push-1.0/xdi-push-1.0-wd01.xml">OASIS XDI 1.0 Push Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-push.html">&latest-loc;/xdi-push.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-policy-1.0">
      <abbrev>OASIS-XDI-Policy-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-policy-1.0/xdi-policy-1.0-wd01.xml">OASIS XDI 1.0 Policy Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-policy.html">&latest-loc;/xdi-privacy.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-security-mechanisms-1.0">
      <abbrev>OASIS-XDI-Security-Mechanisms-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-security-mechanisms-1.0/xdi-security-mechanisms-1.0-wd01.xml">OASIS XDI 1.0 Security Mechanisms Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-security-mechanisms.html">&latest-loc;/xdi-security-mechanisms.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="xdi-privacy-mechanisms-1.0">
      <abbrev>OASIS-XDI-Privacy-Mechanisms-V1.0</abbrev> <date>&pubdate; </date>
      <title><ulink url="../../xdi-privacy-mechanisms-1.0/xdi-privacy-mechanisms-1.0-wd01.xml">OASIS XDI 1.0 Privacy Mechanisms Specification</ulink></title>
      <author><firstname>Markus </firstname> <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname> <surname>Reed</surname></author>.
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-privacy-mechanisms.html">&latest-loc;/xdi-privacy.html</ulink>.</citetitle>
    </bibliomixed> <bibliomixed id="rfc2119">
      <abbrev>RFC 2119</abbrev><date>March 1997</date>
      <title><ulink url="http://www.ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</ulink></title>
      <author><firstname>S. </firstname> <surname>Bradner</surname></author>. 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed> <bibliomixed id="rfc6749">
      <abbrev>RFC 6749</abbrev><date>October 2012</date>
      <title><ulink url="http://www.ietf.org/rfc/rfc6749.txt">The OAuth 2.0 Authorization Framework</ulink></title>
      <author><firstname>D. </firstname> <surname>Hardt </surname></author>, 
       <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed> <bibliomixed id="rfc6750">
      <abbrev>RFC 6750</abbrev><date>October 2012</date>
      <title><ulink url="http://www.ietf.org/rfc/rfc6750.txt">The OAuth 2.0 Authorization Framework: Bearer Token Usage</ulink></title>
      <author><firstname>M. </firstname> <surname>Jones</surname></author>. 
      <author><firstname>D. </firstname> <surname>Hardt</surname></author>, 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed>
  </bibliolist>

</section>

<section><title>Non-Normative References</title>

  <bibliolist>
  </bibliolist>

</section>

</section>

<section><title>XDI Messaging</title>

<para>XDI messaging is the mechanism for transmitting <firstterm>messages</firstterm> between peers, for the purpose
of exchanging data between the graphs for which the peers are authoritative.</para>
<para>Every message is transmitted from a <firstterm>sending peer</firstterm> to a <firstterm>receiving peer</firstterm>.</para>
<para>The XDI messaging process consists of round-trips, each one of which involves a <firstterm>request message</firstterm> which is followed by a corresponding <firstterm>response</firstterm>.</para>
<para>A peer sending a request message is called <firstterm>requesting peer</firstterm> (or short <firstterm>requester</firstterm>). A
peer sending a response is called <firstterm>responding peer</firstterm> (or short <firstterm>responder</firstterm>).</para>
<para>A request message contains one or more <firstterm>request operations</firstterm>, which can perform
queries and/or apply modifications to a graph for which the responder is authoritative. This graph is called
the <firstterm>target graph</firstterm>.</para>
<para>When a request message is executed by the responder against the target graph, a <firstterm>result graph</firstterm>
is generated, which represents the result of the request operations. The result graph MAY be empty.
</para>
<para>A response sent from the responder to the requester may either simply be the result graph itself,
or it may be a <firstterm>response message</firstterm>, which contains within itself the result graph.
</para>
<para>The following diagram shows a typical XDI messaging ip:</para>

<para>
  <figure float="true"><title>XDI Messaging Terminology</title>
   <mediaobject>
    <imageobject>
	<imagedata fileref="xdi-messaging-terminology.png" />
    </imageobject>
    </mediaobject>
    </figure>
</para>

<para>For the request message, the requester is the
sending peer, and the responder is the receiving peer.</para>

<para>For the response, the responder is the sending peer, and the requester is the receiving peer.</para>

<para>A <firstterm>message</firstterm> is itself a context node in a graph, so it can be addressed, serialized, stored,
shared, and controlled by link contracts. When a graph containing one or more messages is serialized and transmitted
between peers, then that graph is called a <firstterm>message envelope</firstterm>.</para>

<section><title>Bindings</title>

<para>
XDI messaging is defined in an abstract way and does not rely on any specific network topology or protocol.
The XDI Bindings <xref linkend='xdi-bindings-1.0'/> specification defines
three concrete ways how messages can be transmitted over a network:</para>
<orderedlist>
<listitem><para>XDI Direct Binding: Request and response messages are transmitted between the requester and the responder via HTTP POST operations.</para></listitem>
<listitem><para>XDI Browser Binding: Request and response messages are transmitted between the requester and the responder via a web browser and a sequence of HTTP form submit and redirect operations.</para></listitem>
<listitem><para>XDI Websocket Binding: Request and response messages are transmitted between the requester and the responder via Websocket sessions.</para></listitem>
</orderedlist>

<para>From an abstract XDI messaging perspective, any peer can act as a requester and responder. In the context
of specific bindings, a distinction can be made between <firstterm>XDI endpoints</firstterm>
and <firstterm>XDI agents</firstterm>.</para>

<para>An XDI endpoint is a peer that &#8211; within the context of a specific binding &#8211; has an endpoint URI
on a network. The three bindings above all require such endpoint URIs, which are discoverable given the XDI peer address
(see <xref linkend='xdi-discovery-1.0'/>). An XDI endpoint can always act as both
requesting peer and responding peer.</para>

<para>An XDI agent is a peer that &#8211; within the context of a specific binding &#8211; does not have an endpoint
URI on a network. In many situations and bindings, an XDI agent can only act as a requesting peer. One
exception is the XDI Websocket Binding. Once a Websocket connection has been established between two peers, they may
both act as both requesting peer and responding peer, even if one of them is an XDI agent without its own
endpoint URI on a network.</para>

</section>

</section>

<section id="s.messages"><title>Messages</title>

<para>A message is itself a context in a graph. It is a member instance under
an entity collection identified by a <code>[$msg]</code> context, under an entity that
is authoritative for the message. That entity is called the <firstterm>sender</firstterm>
of the message. The member instance is called the <firstterm>message ID</firstterm>.</para>

<programlisting>&lt;--sender--&gt;[$msg]&lt;--message-id--&gt;
</programlisting>

<para>Example message by XDI sender <code>=!:uuid:1111</code>, with message ID <code>*!:uuid:1234</code>:</para>

<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1
</programlisting>

<para>Every message SHOULD have an immutable address. To express order, the ordered/unordered reference pattern
(see <xref linkend="xdi-core-1.0"/>) MAY be used:</para>

<programlisting>=!:uuid:1111[$msg]@~0/$ref/=!:uuid:1111[$msg]*!:uuid:m-1
</programlisting>

<para>A context node representing a message contains various
statements that make up the semantics and purpose of the message.</para>

<para>Following are the statements that are common to both request messages and response
messages (shown in statement format). This is called the <firstterm>common message pattern</firstterm>. Labels in <code>&lt;--this-form--&gt;</code> represent
template variables.</para>

<programlisting>SENDING PEER                &lt;--sending-peer--&gt;/$send/&lt;--sender--&gt;[$msg]&lt;--message-id--&gt;
RECEIVING PEER              &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;/$is()/&lt;--receiving-peer--&gt;
MESSAGE TYPE                &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;/$is#/&lt;--message-type--&gt;[$v]&lt;--version-number--&gt;$xdi[$v]@1$msg
CORRELATION STATEMENT       &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;/$is$msg/&lt;--previous-sender--&gt;[$msg]&lt;--previous-message-id--&gt;
TIMESTAMP                   &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;$t>/&amp;/&lt;--timestamp--&gt;
MESSAGE PARAMETERS          &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;--parameter--&gt;/&amp;/&lt;--parameter-value--&gt;
AUTHENTICATION TOKEN        &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;--token-type--&gt;&lt;$token&gt;/&amp;/&lt;--token--&gt;
AUTHENTICATION SIGNATURE    &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;--signature-type--&gt;&lt;$sig&gt;/&amp;/&lt;--signature--&gt;
</programlisting>

<section id="s.message.sender"><title>Sender</title>

<para>A message MUST have a <firstterm>sender</firstterm> that creates the message.</para>

<orderedlist>
<listitem><para><code>&lt;--sender--&gt;</code> is the XDI address of the sender that creates the message.</para></listitem>
<listitem><para>This XDI address may be any valid XDI entity (e.g., person, organization, thing, device, service, etc.)</para></listitem>
</orderedlist>

</section>

<section id="s.message.id"><title>Message ID</title>

<para>A message MUST have a <firstterm>message ID</firstterm>.</para>

<orderedlist>
<listitem><para><code>&lt;--message-id--&gt;</code> is an entity instance that is the unique ID of the message in the context of the <code>[$msg]</code> collection of messages sent by the sender.</para></listitem>
<listitem><para>The message ID value may be sequential, or based on timestamps, or a random UUID, or use any other algorithm that provides uniqueness in this context.</para></listitem>
<listitem><para>Sending peers MUST use a different message ID for every message.</para></listitem>
<listitem><para>Receiving peers MAY enforce uniqueness of message IDs.</para></listitem>
</orderedlist>

</section>

<section id="s.message.sending.peer"><title>Sending Peer</title>

<para>A message MUST have exactly one <firstterm>sending peer</firstterm>.</para>

<orderedlist>
<listitem><para><code>&lt;--sending-peer--&gt;</code> is the XDI peer (XDI endpoint or agent) sending this message.</para></listitem>
</orderedlist>

</section>

<section id="s.message.receiving.peer"><title>Receiving Peer</title>

<para>A message MUST have at least one <firstterm>receiving peer</firstterm>, and MAY have multiple <firstterm>receiving peers</firstterm>.</para>

<orderedlist>
<listitem><para><code>&lt;--receiving-peer--&gt;</code> is the XDI peer (XDI endpoint or agent) receiving the message.</para></listitem>
<listitem><para>Depending on the binding being used, it may be possible or required to discover an endpoint URI for this peer (see <xref linkend="xdi-discovery-1.0"/>).</para></listitem> 
</orderedlist>

</section>

<section id="s.message.type.version"><title>Message Type and Version</title>

<para>A message MAY have a <firstterm>message type</firstterm> and <firstterm>message version</firstterm>.</para>

<orderedlist>
<listitem><para><code>&lt;--message-type--&gt;</code> is an optional XDI address specifying a message type.</para></listitem>
<listitem><para><code>&lt;--version-number--&gt;</code> is the message type version, expressed as an ordered instance of a <code>[$v]</code> collection.</para></listitem>
</orderedlist>

</section>

<section id="s.message.correlation.statement"><title>Correlation statement</title>

<para>A message MAY have one or more <firstterm>correlation statements</firstterm>, also known as <firstterm>thread statements</firstterm>.
The purpose of such statements is to express that this message is in some way related to a previous message.</para>

<para>For a response message, at least one correlation statement is REQUIRED in order to express that
the response message is related to the request message.</para>

<para>For a request message, a correlation statement MAY express that the request message is related
to previous request or response message.</para>

<para>A correlation statement is identified by a <code>$is$msg</code> relational arc between messages. This identifier MAY be
specialized to express additional semantics about how two messages are related.</para>

<para>Example correlation statement:</para>

<programlisting>=!:uuid:2222[$msg]*!:uuid:m-2/$is$msg/=!:uuid:1111[$msg]*!:uuid:m-1
</programlisting>

</section>

<section id="s.message.timestamp"><title>Timestamp</title>

<para>A message MAY have a <firstterm>timestamp</firstterm> to indicate at which point in time a requester sent the message.</para>

<orderedlist>
<listitem><para><code>&lt;--timestamp--&gt;</code> is the timestamp of the message in XML datetime format as specified by the '''$t''' entry in the XDI $ Dictionary.</para></listitem>
<listitem><para>Receiving peers MAY enforce policies requiring the message <code>&lt;--timestamp--></code> value to be within a certain tolerance.</para></listitem>
</orderedlist>

</section>

<section id="s.message.authentication.token"><title>Authentication Token</title>

<para>A message MAY be authenticated with a token as defined in section 1.4 of <xref linkend="rfc6749"/>.</para>

<orderedlist>
<listitem><para><code>&lt;--token-type--&gt;</code> is the XDI address defining the type of token provided for message authentication.</para></listitem>
<listitem><para><code>&lt;--token--&gt;</code> is the literal token value provided for authentication.</para></listitem>
<listitem><para>The token type <code>&lt;$secret&gt;</code> may be used for shared secrets. Any valid XDI literal value may be used as a shared secret.</para></listitem>
<listitem><para>The token type <code>&lt;$bearer&gt;</code> may be used for bearer tokens as defined by <xref linkend="rfc6750"/>.</para></listitem>
<listitem><para>Other token types as registered with the IANA OAuth Access Token Types Registry defined in section 11.1 of <xref linkend="rfc6749"/>.</para></listitem>
</orderedlist>

</section>

<section id="s.message.authentication.signature"><title>Authentication Signature</title>

<para>A message MAY be signed for authentication. See <xref linkend="xdi-signature1.0"/>.</para>

<orderedlist>
<listitem><para><code>&lt;--signature-type--&gt;</code> is the context defining the type of signature provided for authentication.</para></listitem>
<listitem><para><code>&lt;--signature--&gt;</code> is the literal signature value provided for authentication as required by the referenced link contract.</para></listitem>
</orderedlist>

</section>

<section id="s.message.message.parameters"><title>Message Parameters</title>

<para>A message MAY have one or more <firstterm>message parameters</firstterm> that govern how the message is executed.</para>

<orderedlist>
<listitem><para><code>&lt;--parameter--&gt;</code> is a message parameter.</para></listitem>
<listitem><para><code>&lt;--parameter-value--&gt;</code> is the value of a message parameter.</para></listitem>
<listitem><para>A message parameter MUST be interpreted to apply only to the message that contains it.</para></listitem>
</orderedlist>

<para>The following message parameter is defined by this specification:</para>

<section id="s.message.message.parameter.msg"><title>&lt;$msg></title>

<orderedlist>
<listitem><para>The <code>&lt;$msg></code> message parameter MUST only be used with request messages.</para></listitem>
<listitem><para>The parameter instructs the responder to send a response message rather than simply the result graph
as a response, after the request message has been executed.</para></listitem>
<listitem><para>Valid values are <code>true</code> and <code>false</code>.</para></listitem>
<listitem><para>If this message parameter is not present, the default value is <code>false</code>.</para></listitem>
</orderedlist>

<para>Example:</para>

<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1&lt;$msg&gt;/&amp;/true
</programlisting>

</section>

</section>

</section>

<section id="s.request.messages"><title>Request Messages</title>

<para>A <firstterm>request message</firstterm> MUST conform to the common message pattern
(see <xref linkend="s.messages"/>). In addition, request messages extend the common message pattern
with the following <firstterm>request message pattern</firstterm> (shown in statement format):
</para>

<programlisting>LINK CONTRACT ADDRESS        &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;/$do/&lt;--link-contract-address--&gt;
MESSAGE POLICY               &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;$do$if&lt;--boolean-context--&gt;/&lt;--operation--&gt;/&lt;--condition--&gt;
OPERATION PARAMETERS         &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;--operation--&gt;&lt;--parameter--&gt;/&amp;/&lt;--parameter-value--&gt;
VARIABLE ADDRESS ASSIGNMENT  &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;--operation--&gt;&lt;--variable--&gt;/$is/&lt;--variable-value--&gt;
VARIABLE LITERAL ASSIGNMENT  &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;&lt;--operation--&gt;&lt;--variable--&gt;/&amp;/"&lt;--variable-value--&gt;"
OPERATION ON ADDRESS         &lt;--sender--&gt;[$msg]&lt;--message-id--&gt;$do/&lt;--operation--&gt;/&lt;--target-address--&gt;
OPERATION ON INNER GRAPH     (&lt;--sender--&gt;[$msg]&lt;--message-id--&gt;$do/&lt;--operation--&gt;)&lt;--target-inner-graph--&gt;
</programlisting>

<para>Where:</para>
<orderedlist>
<listitem><para><code>&lt;--link-contract-address--&gt;</code> is the XDI address of the link contract authorizing the requested operation on the requested object graph. This MUST be either: a) a <code>$do</code> entity singleton or: b) a <code>[$do]</code> entity class followed by an entity instance. See the XDI Policy specification: <xref linkend='xdi-policy-1.0'/>.</para></listitem>
<listitem><para><code>&lt;--boolean-context--&gt;</code> is defined in <xref linkend='xdi-policy-1.0'/>.</para></listitem>
<listitem><para><code>&lt;--operation--&gt;</code> is defined in <xref linkend='xdi-policy-1.0'/>.</para></listitem> 
<listitem><para><code>&lt;--condition--&gt;</code> is defined in <xref linkend='xdi-policy-1.0'/>.</para></listitem>
<listitem><para><code>&lt;--operation--&gt;</code> is the request operation (<code>$get, $set, $add, $mod, $del, $connect, $send, $push, $do</code>). A request operation may be executed on an address or on an inner root. There may be one or more operations in a message.</para></listitem>
<listitem><para><code>&lt;--parameter--&gt;</code> is an operation parameter.</para></listitem>
<listitem><para><code>&lt;--parameter-value--&gt;</code> is the value of an operation parameter.</para></listitem>
<listitem><para><code>&lt;--target-address--&gt;</code> is an XDI address that the operation is executed on.</para></listitem> 
<listitem><para><code>&lt;--target-inner-graph--&gt;</code> is an XDI inner graph containing statements that the operation is executed on.</para></listitem> 
</orderedlist>

<para>Example request message:</para>

<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1/$do/(=!:uuid:2222/=!:uuid:1111)$get[$do]*!:uuid:
=!:uuid:1111[$msg]*!:uuid:m-1$do/$get/=!:uuid:2222&lt;#email>
</programlisting>

<section id="s.request.message.link.contract.address"><title>Link Contract Address</title>

<orderedlist>
<listitem><para>Request messages MUST include a <code>&lt;--link-contract-address--&gt;</code> reference to the XDI link contract authorizing that message. See the [[Link Contract Pattern]]. Requiring the <code>&lt;--link-contract--&gt;</code> reference in an XDI message makes it much more efficient for XDI servers to perform authentication and authorization, because they know which link contract to evaluate. (For a public link contract, the value of <code>&lt;--link-contract--&gt;</code> is <code>$public$do</code>.)</para></listitem>
<listitem><para>Request messages MUST be executed only if the [[XdiPolicyExpression|link contract policies]] evaluates to <code>true</code>.</para></listitem>
</orderedlist>

</section>

<section id="s.request.message.message.policy"><title>Message Policy</title>

<orderedlist>
<listitem><para>A request message MAY have a policy c to govern their execution at an XDI endpoint.</para></listitem>
<listitem><para>If an XDI message includes a <code>&lt;--sender--&gt;[$msg]&lt;--id--&gt;$do$if</code> sub context, the set of message policy statements in this context MUST be evaluated by the XDI endpoint.</para></listitem>
<listitem><para>Request messages MUST be executed only if the [[XdiPolicyExpression|link contract policies]] evaluates to <code>true</code>.</para></listitem>
<listitem><para>For privacy reasons, a message policy may only access parts of the target graph which it has <code>$get</code> access to under the link contract referenced in the message.</para></listitem>
</orderedlist>

</section>

<section id="s.request.message.operation.parameters"><title>Operation Parameters</title>

<orderedlist>
<listitem><para>A request operation MAY have one or more <firstterm>operation parameters</firstterm> that govern how the request operation is executed.</para></listitem>
<listitem><para>An operation parameter MUST apply only to the request operation that contains it.</para></listitem>
</orderedlist>

<para>The following operation parameters are defined by this specification.</para>

<section><title>&lt;$deref></title>

<orderedlist>
<listitem><para>The <code>&lt;$deref></code> MUST only be used with the <code>$get</code> operation.</para></listitem>
<listitem><para>The parameter controls whether the responder automatically dereferences <code>$ref</code> statements in a result graph.</para></listitem>
<listitem><para>Valid values are <code>true</code> and <code>false</code>.</para></listitem>
<listitem><para>If this parameter is not present, the default value is <code>false</code>.</para></listitem>
</orderedlist>

<para>Example:</para>

<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$get&lt;$deref&gt;/&amp;/true
</programlisting>

</section>

<section><title>&lt;$proxy></title>

<orderedlist>
<listitem><para>The <code>&lt;$proxy></code> MUST only be used with the <code>$get</code> operation.</para></listitem>
<listitem><para>The parameter controls whether the responder acts as a proxy to complete discovery of an XDI context for which the responder is not itself authoritative.</para></listitem>
<listitem><para>Valid values are <code>true</code> and <code>false</code>.</para></listitem>
<listitem><para>If this parameter is not present, the default value is <code>false</code>.</para></listitem>
</orderedlist>

<para>Example:</para>

<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$get&lt;$proxy&gt;/&amp;/true
</programlisting>

</section>

</section>

<section id="s.request.message.variable.assignments"><title>Variable Assignment</title>

<orderedlist>
<listitem><para>A request operation MAY have one or more <firstterm>variable assignments</firstterm> that are used when the request operation is executed.</para></listitem>
<listitem><para>A variable assignment MUST apply only to the request operation that contains it.</para></listitem>
<listitem><para>For certain operations it is REQUIRED that variables are assigned values.</para></listitem>
<listitem><para>For certain operations it is OPTIONAL that variables are assigned values.</para></listitem>
<listitem><para>See the definitions of individual operation for information whether it uses variables,
which variables it uses, how
they are used, and whether it is required or optional to assign values to the variables.</para></listitem>
</orderedlist>

<para>Example:</para>

<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$connect{$get}/$is/=!:uuid:2222&lt;#email>
</programlisting>

</section>

</section>

<section id="s.response"><title>Response</title>

<para>Every request message MUST have a corresponding response which is transmitted back from the
responder to the requester, in a way defined by the binding that is being used. There are two types
of responses. <firstterm>Result graphs</firstterm> and <firstterm>response messages</firstterm>.</para>

<para>If the <code>&lt;$msg&gt;</code> message parameter (see <xref linkend="s.message.message.parameter.msg"/>) is absent or set to <code>false</code>, then the response MUST be
a result graph.</para>
<para>If the <code>&lt;$msg&gt;</code> message parameter is set to <code>true</code>, then the response MUST be
a response message.</para>

<section id="s.response.result.graph"><title>Result Graph</title>

<para>A <firstterm>result graph</firstterm> consists of the result statements of a request operation.
The result graph is not itself a message and therefore does not conform to the common message pattern
(see <xref linkend="s.messages"/>).</para>

<para>Every request operation has its own result graph. If a request message contains multiple
request operations, and/or a request message envelope contains multiple request messages, then a
<firstterm>combined result graph</firstterm> is created that is the union of all result graphs.</para>

<para>Example result graph:</para>

<programlisting>=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111</programlisting>

</section>

<section id="s.response.message"><title>Response Message</title>

<para>A <firstterm>response message</firstterm> MUST conform to the common message pattern
(see <xref linkend="s.messages"/>). In addition, response messages extend the common message pattern
with the following <firstterm>response message pattern</firstterm> (shown in statement format):
</para>

<programlisting>OPERATION RESULT GRAPHS  (&lt;--sender--&gt;[$msg]&lt;--message-id--&gt;/&lt;--operation--&gt;)&lt;--result-graph--&gt;
DEFERRED PUSH CONTRACTS  (&lt;--sender--&gt;[$msg]&lt;--message-id--&gt;/&lt;--operation-->$defer$push)&lt;--deferred-push-contracts--&gt;</programlisting>

<section id="s.response.message.operation.result.graphs"><title>Operation Result Graphs</title>

<para>
The result graphs of the
request operations are included in the response message using inner root nodes as follows:</para>
<itemizedlist>
<listitem><para>For each request operation in the request message, an inner root node
is created in the response message to represent the result graph of that particular request operation.</para></listitem>
<listitem><para>The subject of the inner root node's XDI address is the XDI address of
the request message to which the response message corresponds.</para></listitem>
<listitem><para>The predicate of the inner root node's XDI address is the identifier of the request operation to
which the result graph corresponds.</para></listitem>
<listitem><para>The inner graph under the inner root node is the result graph of the request operation.</para></listitem>
</itemizedlist>

<para>Example response message with a result graph:</para>

<programlisting>(=!:uuid:2222)/$send/=!:uuid:2222[$msg]*!:uuid:m-2
=!:uuid:2222[$msg]*!:uuid:m-2/$is()/(=!:uuid:1111)
=!:uuid:2222[$msg]*!:uuid:m-2/$is$msg/=!:uuid:1111[$msg]*!:uuid:m-1
(=!:uuid:2222[$msg]*!:uuid:m-2/$get)=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
(=!:uuid:2222[$msg]*!:uuid:m-2/$get)=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>

</section>

<section id="s.response.message.deferred.push.contracts"><title>Deferred Push Contracts</title>

<para>EDITORIAL NOTE: Maybe some parts of this section should be moved to <xref linkend="xdi-policy-1.0"/>.</para>

<para>A response message may have one or more <glossterm>deferred push contracts</glossterm>,
which indicate that a result graph is not yet available, and that a request operation has
therefore been <firstterm>deferred</firstterm>.</para>

<para><glossterm>Deferred push contracts</glossterm> are <glossterm>push contracts</glossterm> 
(see <xref linkend="s.push.contracts"/>) that are used for handling deferred request operations.</para>

<para>A request operation may be deferred for the following reasons:</para>

<itemizedlist>
<listitem><para>The operation is executed asynchronously. The result graph of the operation will be
pushed once execution is complete.</para></listitem>
<listitem><para>The operation cannot be executed at the moment. It will be executed as soon as possible,
and the result graph of the operation will be pushed once execution is complete.</para></listitem>
<listitem><para>The request operation is deferred due to link contract policy (see <xref linkend="xdi-policy-1.0"/>).
It is expected to be approved or rejected at a future point in time (see <xref linkend="a.common.messaging.patterns.approval"/>
and <xref linkend="a.common.messaging.patterns.rejection"/>).
</para></listitem>
<listitem><para>For other reasons that are out of scope of this specification.</para></listitem>
</itemizedlist>

<para>In the above cases, <glossterm>deferred push contracts</glossterm> are created automatically 
in the responder's target graph and returned in the response message. To create a
<glossterm>deferred push contract</glossterm>, the link contract instantiation function
(see <xref linkend="s.link.contract.instantiation"/>) is invoked with the following input parameters:</para>

<itemizedlist>
<listitem>The link contract template is <code>$defer$push{$do}</code> (see <xref linkend="s.standard.deferred.push.link.contract.template"/>).</listitem>
<listitem>The variable <code>{$from}</code> is assigned the sending peer of the request operation (see <xref linkend="s.message.sending.peer"/>).</listitem>
<listitem>The variable <code>{$to}</code> is assigned the receiving peer of the request operation (see <xref linkend="s.message.receiving.peer"/>).</listitem>
<listitem>The variable <code>{$push}</code> is assigned the address of the context(s) of the result graph that are not yet available.</listitem>
<listitem>The <glossterm>instance flag</glossterm> set to "instance"</listitem>
</itemizedlist>

<para>Example instantiated deferred push contract:</para>

<programlisting>(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2/$push/=!:uuid:2222&lt;#email>
(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2/$is()/(=!:uuid:1111)
(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2$if$and/$true){$from}/$is/=!:uuid:2222
(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2$if$and/$true){$msg}/$is$msg/=!:uuid:1111[$msg]*!:uuid:m-1
</programlisting>

<para>A request operation MAY have both a result graph and a deferred push contract in the response message,
indicating that a partial result is available immediately, and that additional results will be available
in the future.</para>

<para>A request operation MAY have more than one corresponding deferred push contract, if the result
graph will be delivered in multiple pushes.</para>

<para>Example response message with a deferred push contract:</para>

<programlisting>(=!:uuid:2222)/$send/=!:uuid:2222[$msg]*!:uuid:m-2
=!:uuid:2222[$msg]*!:uuid:m-2/$is()/(=!:uuid:1111)
=!:uuid:2222[$msg]*!:uuid:m-2/$is$msg/=!:uuid:1111[$msg]*!:uuid:m-1
(=!:uuid:2222[$msg]*!:uuid:m-2/$get$defer$push)(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2/$push/=!:uuid:2222&lt;#email>
(=!:uuid:2222[$msg]*!:uuid:m-2/$get$defer$push)(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2/$is()/(=!:uuid:1111)
(=!:uuid:2222[$msg]*!:uuid:m-2/$get$defer$push)(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2$if$and/$true){$from}/$is/=!:uuid:2222
(=!:uuid:2222[$msg]*!:uuid:m-2/$get$defer$push)(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
(=!:uuid:2222[$msg]*!:uuid:m-2/$get$defer$push)(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2$if$and/$true){$msg}/$is$msg/=!:uuid:1111[$msg]*!:uuid:m-1
</programlisting>

</section>

</section>

</section>

<section id="s.operations"><title>Operations</title>

<para>Operations constitute the body of an XDI message.</para>
<orderedlist>
<listitem><para>A request message MUST contain at least one operation statement.</para></listitem>
<listitem><para>To successfully complete execution of a request message, a responder MUST complete execution of each operation requested in each operation statement in the message.</para></listitem>
</orderedlist>

<para>Depending on: a) the operation, and b) whether the operation target is an XDI address or
an inner graph, the following operations and behaviors are possible:</para>

<table><title>XDI Operations Overview</title><tgroup cols="3"><thead>
<row><entry></entry><entry>on address</entry><entry>on inner graph</entry></row>
</thead><tbody>
<row><entry><code>$get</code></entry><entry>retrieves graph/subgraph</entry><entry>retrieves individual contextual/relational/literal statement(s)</entry></row>
<row><entry><code>$set</code></entry><entry>creates or modifies context node plus parent context node(s) if needed</entry><entry>creates or modifies individual contextual/relational/literal statement(s) plus parent context nodes(s) if needed</entry></row>
<row><entry><code>$add</code></entry><entry>creates new context node plus parent context node(s) if needed</entry><entry>creates new individual contextual/relational/literal statement(s) plus parent context nodes(s) if needed</entry></row>
<row><entry><code>$mod</code></entry><entry>(invalid)</entry><entry>modifies existing literal statement(s)</entry></row>
<row><entry><code>$del</code></entry><entry>deletes context node and subgraph</entry><entry>deletes individual contextual/relational/literal statement(s) plus subgraph(s)</entry></row>
<row><entry><code>$connect</code></entry><entry>requests instantiation of a link contract</entry><entry>requests instantiation of a link contract</entry></row>
<row><entry><code>$send</code></entry><entry>requests sending of an inner message</entry><entry>requests sending of an inner message</entry></row>
<row><entry><code>$push</code></entry><entry>delivers a notification based on a push link contract</entry><entry>delivers a notification based on a push link contract</entry></row>
<row><entry><code>$do</code></entry><entry>(unspecified)</entry><entry>(unspecified)</entry></row>
</tbody></tgroup></table>

<section id="s.operation.get"><title><code>$get</code> operation</title>

<para>The <code>$get</code> operation retrieves XDI statements from a target graph and does not make changes to that graph.</para>

<section><title><code>$get</code> applied to an address</title>

<para>The result graph contains the subgraph at the provided address if it exists.
If the subgraph does not exist, the result graph is empty.</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>And the following <code>$get</code> operation on address <code>=!:uuid:2222</code>:</para>
<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$do/$get/=!:uuid:2222
</programlisting>
<para>The result graph will be:</para>
<programlisting>=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>

</section>

<section><title><code>$get</code> applied to an inner graph</title>

<para>The result graph contains the provided statements of the inner graph if they exist.
If the statements do not exist, the result graph is empty (this is not considered an error).</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>And the following <code>$get</code> operation on statement <code>=!:uuid:2222/#friend/=!:uuid:1111</code>:</para>
<programlisting>(=!:uuid:1111[$msg]*!:uuid:m-1$do/$get)=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>The result graph will be:</para>
<programlisting>=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>

</section>

</section>

<section id="s.operation.set"><title><code>$set</code> operation</title>

<para>The <code>$set</code> operation creates or modifies data in a target graph. Unless an error occurs, the result graph is the empty graph.</para>

<section><title><code>$set</code> applied to an address</title>

<para>This operation creates a context node at the provided address, as well as any parent context node(s) as needed.
If the context node exists already, the operation has no effect (this is not considered an error).</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
//=!:uuid:2222
</programlisting>
<para>And the following <code>$set</code> operation on address <code>=!:uuid:2222&lt;#email></code>:</para>
<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$do/$set/=!:uuid:2222&lt;#email>
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222//&lt;#email>
</programlisting>

</section>

<section><title><code>$set</code> applied to an inner graph</title>

<para>This operation creates the provided statements of the inner graph, as well as any parent context nodes(s) as needed.
If a statement exists already, the operation has no effect on this statement (this is not considered an error).</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;//#email>
</programlisting>
<para>And the following <code>$set</code> operation on statements <code>=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"</code> and <code>=!:uuid:2222/#friend/=!:uuid:1111</code>:</para>
<programlisting>(=!:uuid:1111[$msg]*!:uuid:m-1$do/$set)=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$set)=!:uuid:2222/#friend/=!:uuid:1111 
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>

</section>

</section>

<section id="s.operation.add"><title><code>$add</code> operation</title>

<para>The <code>$add</code> operation creates data in a target graph. Unless an error occurs, the result graph is the empty graph.
If the operation is applied to data which already exists, it generates an error
(this is what distinguishes <code>$add</code> from <code>$set</code>).</para>

<section><title><code>$add</code> applied to an address</title>

<para>This operation creates a context node at the provided address, as well as any parent context node(s) as needed.
If the context node exists already, the operation generates an error.</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
//=!:uuid:2222
</programlisting>
<para>And the following <code>$add</code> operation on address <code>=!:uuid:2222&lt;#email></code>:</para>
<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$do/$add/=!:uuid:2222&lt;#email>
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222//&lt;#email>
</programlisting>

</section>

<section><title><code>$add</code> applied to an inner graph</title>

<para>This operation creates the provided statements of the inner graph, as well as any parent context nodes(s) as needed.
If a statement exists already, the operation generates an error.</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;//#email>
</programlisting>
<para>And the following <code>$add</code> operation on statements <code>=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"</code> and <code>=!:uuid:2222/#friend/=!:uuid:1111</code>:</para>
<programlisting>(=!:uuid:1111[$msg]*!:uuid:m-1$do/$add)=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$add)=!:uuid:2222/#friend/=!:uuid:1111 
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>

</section>

</section>

<section id="s.operation.mod"><title><code>$mod</code> operation</title>

<para>The <code>$mod</code> operation modifies data in a target graph. Unless an error occurs, the result graph is the empty graph.
If the operation is applied to data which does not exist, it generates an error
(this is what distinguishes <code>$mod</code> from <code>$set</code>).</para>

<section><title><code>$mod</code> applied to an address</title>

<para>This operation on an address is not defined and generates an error.</para>

</section>

<section><title><code>$mod</code> applied to an inner graph</title>

<para>This operation is only defined on literal statements and generates an error otherwise.
It modifies the value of an existing literal statement.
If the context node that contains the literal does not exist, the operation generates an error.</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>And the following <code>$mod</code> operation on statement <code>=!:uuid:2222&lt;#email>/&amp;/"alice@new.com"</code>:</para>
<programlisting>(=!:uuid:1111[$msg]*!:uuid:m-1$do/$set)=!:uuid:2222&lt;#email>/&amp;/"bob@new.com"
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>=!:uuid:2222&lt;#email>/&amp;/"bob@new.com"
</programlisting>

</section>

</section>

<section id="s.operation.del"><title><code>$del</code> operation</title>

<para>The <code>$del</code> operation deletes data from a target graph. Unless an error occurs, the result graph is the empty graph.</para>

<section><title><code>$del</code> applied to an address</title>

<para>This operation deletes a context node at the provided address, as well as its entire subgraph.
If the context node does not exist, the operation has no effect (this is not considered an error).</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222&lt;#email>/&amp;/"bob@email.com"
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>And the following <code>$del</code> operation on target address <code>=!:uuid:1111&lt;#email></code>:</para>
<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$do/$del/=!:uuid:2222&lt;#email>
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>

</section>

<section><title><code>$del</code> applied to an inner graph</title>

<para>This operation deletes the provided statements of the inner graph.
For a contextual statement, the operation also deletes the entire subgraph of the context node.
For a relational statement, the operation deletes neither the source context node nor the target context node of the relation, only the relation itself.
If a statement does not exist, the operation has no effect (this is not considered an error).</para>
<para>Example: Given the following target graph:</para>
<programlisting>//+!:uuid:0000
=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>And the following <code>$del</code> operation on statement <code>=!:uuid:2222/#friend/=!:uuid:1111</code>:</para>
<programlisting>(=!:uuid:1111[$msg]*!:uuid:m-1$do/$del)=!:uuid:2222/#friend/=!:uuid:1111
</programlisting>
<para>The target graph after the operation will be:</para>
<programlisting>//+!:uuid:0000
//=!:uuid:2222
//=!:uuid:1111
</programlisting>

</section>

</section>

<section id="s.operation.connect"><title><code>$connect</code> operation</title>

<para>The <code>$connect</code> operation requests instantiation of a link contract.</para>

<section><title><code>$connect</code> applied to an address</title>

<para>The provided address MUST be the address of a link contract template.
The link contract template MUST be discovered from this address (see <xref linkend="xdi-discovery-1.0"/>).</para>

<para>Example:</para>
<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1$do/$connect/$get{$do}
=!:uuid:1111[$msg]*!:uuid:m-1$connect{$get}/$is/=!:uuid:2222&lt;#email>
</programlisting>

</section>

<section><title><code>$connect</code> applied to an inner graph</title>

<para>The provided inner graph MUST contain one or more link contract templates.</para>

<para>Example:</para>
<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$connect)$get{$do}/$get/{$get}
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$connect)($get{$do}$if$and/$true){{$from}}/$is/{$from}
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$connect)($get{$do}$if$and/$true){{$msg}}&lt;$sig>&lt;$valid>/&amp;/true
=!:uuid:1111[$msg]*!:uuid:m-1$connect{$get}/$is/=!:uuid:2222&lt;#email>
</programlisting>

</section>

<section><title>Executing the <code>$connect</code> Operation</title>

<para>To execute the <code>$connect</code> operation, link contract(s) are instantiated from the link
contract template(s).</para>

<para>The link contract instantiation function (see <xref linkend="s.link.contract.instantiation"/>) is
invoked with the following input parameters:</para>

<itemizedlist>
<listitem>The link contract template(s) are provided by the <code>$connect</code> operation as described above.</listitem>
<listitem>The variable <code>{$from}</code> is assigned the sending peer of the <code>$connect</code> operation (see <xref linkend="s.message.sending.peer"/>).</listitem>
<listitem>The variable <code>{$to}</code> is assigned the receiving peer of the <code>$connect</code> operation (see <xref linkend="s.message.receiving.peer"/>).</listitem>
<listitem>Additional variable assignments required by the link contract template MUST be provided by the <code>$connect</code> operation (see <xref linkend="s.request.message.variable.assignments"/>).</listitem>
<listitem>The <glossterm>instance flag</glossterm> set to "instance" (TODO: how can a $connect operation specify this flag?)</listitem>
</itemizedlist>

<para>The instantiated link contract is written into the target graph. The result graph
is the empty graph.</para>

</section>

</section>

<section id="s.operation.send"><title><code>$send</code> operation</title>

<para>The <code>$send</code> operation requests sending of an inner message.</para>

<section><title><code>$send</code> applied to an address</title>

<para>The provided address MUST be either the address of a message or the address of a message template.</para>

<para>If the provided address is the address of a message, then the message MUST be
discovered from this address (see <xref linkend="xdi-discovery-1.0"/>). This message is called
the <firstterm>inner request message</firstterm>.</para>

<para>Example:</para>
<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1$do/$send/=!:uuid:2222[$msg]*!:uuid:m-2
</programlisting>

<para>If the provided address is the address of a message template, then the message template MUST be
discovered from this address (see <xref linkend="xdi-discovery-1.0"/>). The message template is used
to instantiate a message. This message is called <firstterm>inner request message</firstterm>.</para>

<para>The message instantiation function (see <xref linkend="s.message.instantiation"/>) is
invoked with the following input parameters:</para>

<itemizedlist>
<listitem>The message template is provided by the <code>$send</code> operation as described above.</listitem>
<listitem>The variable <code>{$from}</code> is assigned the receiving peer of the <code>$send</code> operation (see <xref linkend="s.message.receiving.peer"/>).</listitem>
<listitem>The variable <code>{$to}</code> MUST be provided by the <code>$send</code> operation (see <xref linkend="s.request.message.variable.assignments"/>).</listitem>
<listitem>The variable <code>{$do}</code> MUST be provided by the <code>$send</code> operation (see <xref linkend="s.request.message.variable.assignments"/>).</listitem>
<listitem>Additional variable assignments required by the message template MUST be provided by the <code>$send</code> operation (see <xref linkend="s.request.message.variable.assignments"/>).</listitem>
</itemizedlist>

<para>Example:</para>
<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1$do/$send/$get{$msg}
=!:uuid:1111[$msg]*!:uuid:m-1$send{$to}/$is/=!:uuid:3333
=!:uuid:1111[$msg]*!:uuid:m-1$send{$do}/$is/(=!:uuid:3333/=!:uuid:2222)$get$do
=!:uuid:1111[$msg]*!:uuid:m-1$send{$get}/$is/=!:uuid:3333&lt;#email>
</programlisting>

</section>

<section><title><code>$send</code> applied to an inner graph</title>

<para>The provided inner graph MUST contain one or more messages.
These messages are called <firstterm>inner request messages</firstterm>.</para>

<para>Example:</para>
<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$send)(=!:uuid:2222)/$send/=!:uuid:2222[$msg]*!:uuid:m-2
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$send)=!:uuid:2222[$msg]*!:uuid:m-2/$is()/(=!:uuid:3333)
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$send)=!:uuid:2222[$msg]*!:uuid:m-2/$do/(=!:uuid:3333/=!:uuid:2222)$get$do
(=!:uuid:1111[$msg]*!:uuid:m-1$do/$send)=!:uuid:2222[$msg]*!:uuid:m-2$do/$get/=!:uuid:3333&lt;#email>
</programlisting>

</section>

<section><title>Executing the <code>$send</code> Operation</title>

<para>To execute the <code>$send</code> operation, a new XDI messaging round-trip is initiated in order
to send the inner request message(s).</para>

<itemizedlist>
<listitem>The original request message containing the <code>$send</code> operation
is called the <firstterm>outer request message</firstterm>.</listitem>
<listitem>The requester of the outer request message is called the <firstterm>outer requester</firstterm>.</listitem>
<listitem>The responder of the outer request message is called the <firstterm>outer responder</firstterm>.</listitem>
<listitem>The requester of the inner request message is called the <firstterm>inner requester</firstterm>.</listitem>
<listitem>The responder of the inner request message is called the <firstterm>inner responder</firstterm>.</listitem>
</itemizedlist>

<para>This new XDI messaging round-trip is executed between the inner requester and the inner responder.</para>

<para>An inner message may itself contain one or more <code>$send</code> request operations which
in turn have their own inner messages. This results in a chain of multiple inner messages.</para>

<para>The <code>$send</code> operation is the basis for many common messaging patterns (see <xref linked="a.common.messaging.patterns"/>).</para>

<para>TODO: describe here how a original responder delivers inner messages to the inner responder.</para>
<para>TODO: describe how the inner message is sent, i.e. the role of XDI discovery, bindings, and routing.</para>
<para>TODO: describe how a inner message may be manipulated before being sent (either due to XDI attributes, or endpoint configuration, e.g. to add signature).</para>
<para>TODO: describe how link contracts authorize inner messages (should this be in XDI policy?)</para>

</section>

</section>

<section id="s.operation.push"><title><code>$push</code> operation</title>

<para>The <code>$push</code> operation represents a notification triggered by a push contract (see <xref linkend="s.push.contracts"/>).</para>
<para>This operation is specified in <xref linkend="xdi-push-1.0"/></para>

<para>TODO: "light"/"content" terminology?</para> 

<section><title><code>$push</code> applied to an address</title>

<para>The provided address indicates a <firstterm>light push</firstterm>.</para>
<para>The provided address MUST be the address of the context that has changed.</para>

<programlisting>&lt;--publisher--&gt;[$msg]&lt;--message-id--&gt;$do/$is()/(&lt;--subscriber--&gt;)
&lt;--publisher--&gt;[$msg]&lt;--message-id--&gt;$do/$push/&lt;--target-address--&gt;
</programlisting>

</section>

<section><title><code>$push</code> applied to an inner graph</title>

<para>The provided inner graph indicates a <firstterm>content push</firstterm>.</para>
<para>The provided inner graph MUST be the message that triggered the push contract.</para>

<programlisting>&lt;--publisher--&gt;[$msg]&lt;--message-id--&gt;$do/$is()/(&lt;--subscriber--&gt;)
&lt;--publisher--&gt;[$msg]&lt;--message-id--&gt;$do/&lt;--operation--&gt;/&lt;--target-address--&gt;
(&lt;--publisher--&gt;[$msg]&lt;--message-id--&gt;$do/&lt;--operation--&gt;)&lt;--target-statement--&gt;
</programlisting>

</section>

<section><title>Executing the <code>$push</code> Operation</title>

<para>TODO: Describe here how a subscriber executes incoming push messages from a publisher.</para>

<para>Note that when a push message is executed against a subscriber's target graph, it may itself
fulfill the conditions in <xref linkend="s.push.contracts.trigger"/>, which in turn results in a new
push message. This can cause a chain reaction of push messages sent between an arbitrary number of peers.</para>

<para>When a push contract is in place, it SHOULD exist both in the publishing peer's graph and in the
subscribing peer's graph. The existence of the push contract in the subscribing peer's graph serves as
authorization for incoming pushes from the publishing peer's graph.</para>

<para>TODO: authorization should be covered in XDI policy, not here</para>

</section>

</section>

<section id="s.operation.do"><title><code>$do</code> operation</title>

<para>This operation provides an extensibility mechanism for performing potentially complex operations on a target
graph that are not defined by this specification. Such complex operations may be sequences composed
of basic operations, or follow an external logic that cannot be reproduced by basic operations
at all.</para>
<para>For example, an operation called <code>$do#cleanup</code> may be defined to "clean up", i.e. delete,
various parts of a graph, according to a pre-defined set of rules.</para>
<para>Implementors SHOULD document exactly how such operations behave when applied to 
addresses and inner graphs, and provide examples, following
the pattern used in this specification to document the basic operations.</para>

</section>

</section>

<section><title>Message Execution</title>

<orderedlist>
<listitem><para>A message envelope MAY contain more than one message subgraph.</para></listitem>
<listitem><para>A message MAY contain more than one operation statement.</para></listitem>
<listitem><para>An XDI endpoint MUST execute all messages in a message envelope.</para></listitem>
<listitem><para>An XDI endpoint MUST execute all operation statements within a message.</para></listitem>
</orderedlist>

<section><title>Order</title>

<para>In the XDI graph model as a whole, XDI statements are unordered.</para>

<orderedlist>
<listitem><para>Messages within a message envelope (i.e., within the <code>&lt;--sender--&gt;[$msg]</code> collection) MAY be explicitly ordered by appending the <code>@~&lt;--digit--&gt;</code>ordering context to the <code>&lt;--sender--&gt;[$msg]!&lt;--id--&gt;</code> context.</para></listitem>
<listitem><para>Operation statements within a message (i.e., as objects of the <code>&lt;--operation--&gt;</code> predicate) MAY be explicitly ordered by appending the <code>@~&lt;--digit--&gt;</code> ordering context to the <code>&lt;--operation--&gt;</code> predicate.</para></listitem>
<listitem><para>Explicit ordering of messages and operations is OPTIONAL for an XDI client.</para></listitem>
<listitem><para>Support for explicit ordering of messages and operations is REQUIRED for an XDI endpoint.</para></listitem>
<listitem><para>If explicit ordering of messages and operations is not used, then an XDI endpoint MUST NOT make guarantees about the order in which messages in a message envelope are executed, or about the order in which operations in a message are executed.</para></listitem>
<listitem><para>An XDI endpoint MUST guarantee that all operations in one message are executed before operations in another message are executed.</para></listitem>
</orderedlist>

</section>

</section>

<section id="s.push.contracts"><title>Push Contracts</title>

<section id="s.push.contracts.structure"><title>Structure of a Push Contract</title>

<para>EDITORIAL NOTE: This section should be moved to <xref linkend="xdi-policy-1.0"/>.</para>

<para>A push contract is a link contract that expresses a publish/subscribe relationships between 
peers. It enables a peer called  <firstterm>publishing peer</firstterm> (or short <firstterm>publisher</firstterm>)
to notify one or more other peers called <firstterm>subscribing peers</firstterm> (or short <firstterm>subscribers</firstterm>)
of changes in a graph for which the publisher is authoritative.</para>

<para>A publish/subscribe relationship between a publishing authority and a subscribing authority is modeled as
a link contract with certain properties. This link contract is called a <firstterm>push link contract</firstterm>
(or short <firstterm>push contract</firstterm>).</para>

<para>A push contract conforms to the link contract pattern (see <xref linkend='xdi-policy-1.0'/>)
and in addition MUST meet the following conditions:</para>

<orderedlist>
<listitem><para>The link contract's <firstterm>authorizing authority</firstterm> is the publisher.</para></listitem>
<listitem><para>The link contract's <firstterm>requesting authority</firstterm> is the subscriber.</para></listitem>
<listitem><para>The link contract contains one ore more <code>$push</code> permissions.</para></listitem>
<listitem><para>The link contract MAY contain permissions other than <code>$push</code>.</para></listitem>
<listitem><para>The link contract MAY contain one or more <firstterm>push target endpoint URIs</firstterm>.</para></listitem>
<listitem><para>The link contract MAY contain the <firstterm>content flag</firstterm> which specifies whether a subscriber
wishes to use light pushes or content pushes.</para></listitem>
</orderedlist>

<para>Following is the basic structure of a push contract. Labels in <code>&lt;--this-form--&gt;</code> represent
template variables.</para>

<programlisting>(&lt;--publisher--&gt;/&lt;--subscriber--&gt;)$do/$push/&lt;--target-address--&gt;
(&lt;--publisher--&gt;/&lt;--subscriber--&gt;)$do/$is()/&lt;--subscriber-->
(&lt;--publisher--&gt;/&lt;--subscriber--&gt;)($do/$push)&lt;$xdi&gt;&lt;$uri&gt;/&amp;/"&lt;--subscriber endpoint--&gt;"
(&lt;--publisher--&gt;/&lt;--subscriber--&gt;)($do/$push)&lt;$content&gt;/&amp;/&lt;--light-or-content-push--&gt;
</programlisting>

<para>If the push contract does not contain at least one push target endpoint URI, the subscriber's XDI endpoint MUST
be discovered using the XDI Discovery <xref linkend='xdi-discovery-1.0'/> protocol. This XDI endpoint MUST then
be used as the single push target endpoint URI of the push contract.</para>

<para>If the content flag is absent, the default value <code>false</code> (i.e. use light pushes) MUST be assumed.</para>

<para>Like all link contracts, push contracts are unidirectional and only apply to data in the authorizing
authority's graph. In order to set up a bi- or multidirectional publish/subscribe relationship, two or more
push contracts can be created in which multiple peers simultaneously fulfill the publisher and subscriber roles.</para>

</section>

<section id="s.push.contracts.trigger"><title>Triggering a Push Contract</title>

<para>EDITORIAL NOTE: This section should be moved to <xref linkend="xdi-policy-1.0"/>.</para>

<para>A push contract is triggered when the following conditions are met:</para>

<orderedlist>
<listitem><para>An operation is executed against a graph that contains one or more push contracts.</para></listitem>
<listitem><para>The operation is not a <code>$get</code> operation.</para></listitem>
<listitem><para>The target of the operation is a sub-context of any context that is the target of a <code>$push</code> permission of at least one of the push contracts in the graph.</para></listitem>
</orderedlist>

<para>When a push contract is triggered, it initiates one or more XDI messaging round-trips to notify
subscribers. The notification is itself an XDI message. This message is called a <firstterm>push message</firstterm>
(or short <firstterm>push</firstterm>).</para>

<para>A <firstterm>push message</firstterm> MUST conform to the request message pattern
(see <xref linkend="s.request.messages"/>) and in addition MUST meet the following conditions:</para>

<orderedlist>
<listitem><para>The push message uses the <code>$push</code> request operation (see <xref linkend="s.operation.push"/>).</para></listitem>
</orderedlist>

<para>TODO: describe better how a push message is generated and sent</para>
<para>TODO: describe better how the $push operation is used</para>
<para>TODO: describe how a push contract's policy must be evaluated by both sender and receiver</para>
<para>TODO: describe who in the $push message is the requester and who is responder</para>

</section>

</section>

<section id="s.message.instantiation"><title>Message Instantiation</title>

<para><firstterm>Message instantiation</firstterm> is a function which instantiates a new message
from a message template. This function may be invoked in the following ways:</para>

<itemizedlist>
<listitem>When the <code>$send</code> operation is executed on an address of a message template (see <xref linkend="s.operation.send"/>).</listitem>
<listitem>Through other mechanisms that are out of scope of this specification.</listitem>
</itemizedlist>

<para>The function's input parameters are:</para>

<itemizedlist>
<listitem>A <glossterm>message template</glossterm> identified by a <code>{$msg}</code> context.</listitem>
<listitem>A <glossterm>variable assignment</glossterm> for the variable <code>{$from}</code>.
This is used as the <glossterm>sending peer</glossterm> of the instantiated message (see <xref linkend="s.message.sending.peer"/>).</listitem>
<listitem>A <glossterm>variable assignment</glossterm> for the variable <code>{$to}</code>.
This is used as the <glossterm>receiving peer</glossterm> of the instantiated message (see <xref linkend="s.message.receiving.peer"/>).</listitem>
<listitem>A <glossterm>variable assignment</glossterm> for the variable <code>{$do}</code>.
This is used as the address of the <glossterm>link contract</glossterm> of the instantiated message (see <xref linkend="s.request.message.link.contract.address"/>).</listitem>
<listitem>A list of additional <glossterm>variable assignments</glossterm> that may
be required by the message template.</listitem>
</itemizedlist>

<para>The function's output is an instantiated message.</para>

<para>The function operates as follows:
TODO: formal description of the message instantiation function</para>

<para>Example: Given the following input parameters:</para>

<itemizedlist>
<listitem>The message template is <code>$get{$msg}</code> (see <xref linkend="s.standard.get.message.template"/>).</listitem>
<listitem>The variable <code>{$from}</code> is assigned the value <code>=!:uuid:2222</code>.</listitem>
<listitem>The variable <code>{$to}</code> is assigned the value <code>=!:uuid:3333</code>.</listitem>
<listitem>The variable <code>{$do}</code> is assigned the value <code>(=!:uuid:3333/=!:uuid:2222)$get$do</code>.</listitem>
<listitem>The variable <code>{$get}</code> is assigned the value <code>=!:uuid:3333&lt;#email></code>.</listitem>
</itemizedlist>

<para>Then the instantiated message is as follows:</para>

<programlisting>(=!:uuid:2222)/$send/=!:uuid:2222[$msg]*!:uuid:m-2
=!:uuid:2222[$msg]*!:uuid:m-2/$is()/(=!:uuid:3333)
=!:uuid:2222[$msg]*!:uuid:m-2/$do()/(=!:uuid:3333/=!:uuid:2222)$get$do
=!:uuid:2222[$msg]*!:uuid:m-2$do/$get/=!:uuid:3333&lt;#email>
</programlisting>

</section>

<section id="s.link.contract.instantiation"><title>Link Contract Instantiation</title>

<para>EDITORIAL NOTE: This section should be moved to <xref linkend="xdi-policy-1.0"/>.</para>

<para><firstterm>Link contract instantiation</firstterm> is a function which instantiates a new link
contract from a link contract template. This function may be invoked in the following ways:</para>

<itemizedlist>
<listitem>When the <code>$connect</code> operation is executed (see <xref linkend="s.operation.connect"/>).</listitem>
<listitem>When a request operation is deferred (see <xref linkend="s.response.message.deferred.push.contracts"/>).</listitem>
<listitem>Through other mechanisms that are out of scope of this specification.</listitem>
</itemizedlist>

<para>The function's input parameters are:</para>

<itemizedlist>
<listitem>A <glossterm>link contract template</glossterm> identified by a <code>{$do}</code> context.</listitem>
<listitem>A <glossterm>variable assignment</glossterm> for the variable <code>{$from}</code>.
This is used as the <glossterm>requesting authority</glossterm> of the instantiated link contract.</listitem>
<listitem>A <glossterm>variable assignment</glossterm> for the variable <code>{$to}</code>.
This is used as the <glossterm>authorizing authority</glossterm> of the instantiated link contract.</listitem>
<listitem>A list of additional <glossterm>variable assignments</glossterm> that may
be required by the link contract template.</listitem>
<listitem>An <glossterm>instance flag</glossterm> that states whether the link contract is
instantiated as a <code>$do</code> entity singleton or as an instance in a <code>[$do]</code> entity collection.</listitem>
</itemizedlist>

<para>The function's output is an instantiated link contract.</para>

<para>The function operates as follows:
TODO: formal description of the link contract instantiation function</para>

<para>Example: Given the following input parameters:</para>

<itemizedlist>
<listitem>The link contract template is <code>$get{$do}</code> (see <xref linkend="s.standard.get.link.contract.template"/>).</listitem>
<listitem>The variable <code>{$from}</code> is assigned the value <code>=!:uuid:1111</code>.</listitem>
<listitem>The variable <code>{$to}</code> is assigned the value <code>=!:uuid:2222</code>.</listitem>
<listitem>The variable <code>{$get}</code> is assigned the value <code>=!:uuid:2222&lt;#email></code>.</listitem>
<listitem>The instance flag is set to "entity singleton".</listitem>
</itemizedlist>

<para>Then the instantiated link contract is as follows:</para>

<programlisting>(=!:uuid:2222/=!:uuid:1111)$get$do/$get/=!:uuid:2222&lt;#email>
(=!:uuid:2222/=!:uuid:1111)($get$do$if$and/$true){$from}/$is/=!:uuid:1111
(=!:uuid:2222/=!:uuid:1111)($get$do$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

</section>

<section><title>Error Handling Rules</title>

<para>EDITORIAL NOTE: This section is not ready for review.</para>

<para>The template for an error message is:</para>
<programlisting>ERROR TIMESTAMP     $error&lt;$t>/&amp;/&lt;--timestamp--&gt;
ERROR CODES         $error/$do/&lt;--error-code--&gt;
</programlisting>
<para><code>&lt;error-statement></code> is an inner graph of error statements pertaining to the message.</para>
<para>The dictionary for XDI error code statements is still being defined. See MessagingErrorCode.</para>

</section>

<section><title>Error Codes</title>

<para>EDITORIAL NOTE: This section is not ready for review.</para>

<para>Error codes</para>

<informaltable><tgroup cols="3"><thead>
<row><entry>Name</entry><entry>Code</entry><entry>Explanation</entry></row>
</thead><tbody>
<row><entry>Request unknown</entry><entry><code>$false/$error/$request$unknown</code></entry><entry>Request format is unknown. (E.g. request does not contain operation xdi statement.)</entry></row>
<row><entry>Can't process request</entry><entry><code>$false/$error/$request$cant$process</code></entry><entry>General error, such as internal exception, db connection failure, or other not described by another error.</entry></row>
<row><entry>Request forbidden</entry><entry><code>$false/$error/$request$forbidden</code></entry><entry>Operations in request are not allowed by link contract sent by client.</entry></row>
<row><entry>Supported auth type</entry><entry><code>$false/$error/$supported$auth$type$AUTHTYPE</code></entry><entry>Request was denied together with $request$forbidden error code with supported auth types must be returned to let client know, maybe it used wrong auth type.</entry></row>
<row><entry>Authorization data invalid</entry><entry><code>$false/$error/$auth$data$invalid</code></entry><entry>E.g. OpenID token is expired or invalid.</entry></row>
<row><entry>Node does not have child</entry><entry><code>$false/$error/$node$does$not$have$child</code></entry><entry>$get operation requested node that does not have child, so nothing to return.</entry></row>
<row><entry>Graph not found</entry><entry><code>$false/$error/$graph$not$found</code></entry><entry>Graph with specified id was not found on XDI Server.</entry></row>
</tbody></tgroup></informaltable>

</section>

<section><title>Transactional Integrity</title>

<para>EDITORIAL NOTE: This section is not ready for review.</para>

<para>The XDI TC has discussed [[https://en.wikipedia.org/wiki/Database_transaction|transactional integrity]], 
including <ulink url="https://en.wikipedia.org/wiki/ACID">ACID</ulink> and
<ulink url="https://en.wikipedia.org/wiki/Eventual_consistency">BASE</ulink>, but has not yet determined the requirements
that XDI messaging will need to support.</para>

</section>

<appendix id="s.acknowledgements" role="non-normative">
  <title>Acknowledgements</title>

  <para>This specification was written with the generous and appreciated assistance of</para>
</appendix>
  
<appendix id="a.dollarwords" role="non-normative">
  <title>Dollar Words</title>
  
  <para>This appendix contains formal definitions of the XDI dollar words introduced by this specification.</para>
</appendix>
  
<appendix id="a.examples" role="non-normative">
  <title>Examples</title>
  
  <para>This appendix contains XDI messaging examples.</para>
</appendix>

<appendix id="a.standard.link.contract.templates" role="normative"><title>Standard Link Contract Templates</title>

<para>EDITORIAL NOTE: This section should be moved to <xref linkend="xdi-policy-1.0"/>.</para>

<para>The link contract templates defined in this section MUST be recognized by XDI processors
to be part of the common graph. They can be used for <glossterm>link contract instantiation</glossterm>
(see <xref linkend="s.link.contract.instantiation"/>).</para>

<section id="s.standard.root.link.contract.template"><title>Standard Root Link Contract Template</title>

<para>The purpose of the <firstterm>standard root link contract template</firstterm> is to
instantiate link contracts with a <code>$all</code> permission on an entire graph ("root access").</para>

<para>Its policy authorizes messages only from a single specific requester and requires either a valid signature
or a valid secret token.</para>

<para>The standard root link contract template is typically instantiated as a <code>$do</code> entity singleton, since
for any given relationship between two peers, having one <firstterm>root link contract</firstterm> is sufficient.</para>

<para>The <firstterm>standard root link contract template</firstterm>:</para>

<programlisting>$all{$do}/$all/
($all{$do}$if$and/$true){{$from}}/$is/{$from}
($all{$do}$if$and$or/$true){{$msg}}&lt;$secret>&lt;$token>&lt;$valid>/&amp;/true
($all{$do}$if$and$or/$true){{$msg}}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

<para>Example instantiated <firstterm>root link contract</firstterm>:</para>

<programlisting>(=!:uuid:2222/=!:uuid:1111)$all$do/$all/
(=!:uuid:2222/=!:uuid:1111)($all$do$if$and/$true){$from}/$is/=!:uuid:1111
(=!:uuid:2222/=!:uuid:1111)($all$do$if$and/$true){$msg}&lt;$secret>&lt;$token>&lt;$valid>/&amp;/true
(=!:uuid:2222/=!:uuid:1111)($all$do$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

</section>

<section id="s.standard.get.link.contract.template"><title>Standard Get Link Contract Template</title>

<para>The purpose of the <firstterm>standard get link contract template</firstterm> is to
instantiate link contracts with a <code>$get</code> permission on a certain subgraph identified by the
<code>{$get}</code> variable.</para>

<para>Its policy authorizes messages only from a single specific requester and requires a valid signature.</para>

<para>The <firstterm>standard get link contract template</firstterm> is typically instantiated as an instance in a <code>[$do]</code>
entity collection, since
for any given relationship between two peers, multiple <firstterm>get link contracts</firstterm> may exist.</para>

<para>The <firstterm>standard get link contract template</firstterm>:</para>

<programlisting>$get{$do}/$get/{$get}
($get{$do}$if$and/$true){{$from}}/$is/{$from}
($get{$do}$if$and/$true){{$msg}}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

<para>Example instantiated <firstterm>get link contract</firstterm>:</para>

<programlisting>(=!:uuid:2222/=!:uuid:1111)$get[$do]*!:uuid:d-2/$get/=!:uuid:2222&lt;#email>
(=!:uuid:2222/=!:uuid:1111)($get[$do]*!:uuid:d-2$if$and/$true){$from}/$is/=!:uuid:1111
(=!:uuid:2222/=!:uuid:1111)($get[$do]*!:uuid:d-2$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

</section>

<section id="s.standard.push.link.contract.template"><title>Standard Push Link Contract Template</title>

<para>The purpose of the <firstterm>standard push link contract template</firstterm> is to
instantiate push link contracts with a <code>$push</code> permission on a certain subgraph identified by
the <code>{$push}</code> variable.</para>

<para>Its policy authorizes messages only from a single specific requester and requires a valid signature.</para>

<para>The <firstterm>standard push link contract template</firstterm> is typically instantiated as an instance in a <code>[$do]</code>
entity collection, since
for any given relationship between two peers, multiple <firstterm>push link contracts</firstterm> may exist.</para>

<para>The <firstterm>standard push link contract template</firstterm>:</para>

<programlisting>$push{$do}/$push/{$push}
$push{$do}/$is()/{($from)}
($push{$do}$if$and/$true){{$from}}/$is/{$to}
($push{$do}$if$and/$true){{$msg}}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

<para>Example instantiated <firstterm>push link contract</firstterm>:</para>

<programlisting>(=!:uuid:2222/=!:uuid:1111)$push[$do]*!:uuid:d-2/$push/=!:uuid:2222&lt;#email>
(=!:uuid:2222/=!:uuid:1111)$push[$do]*!:uuid:d-2/$is()/(=!:uuid:1111)
(=!:uuid:2222/=!:uuid:1111)($push[$do]*!:uuid:d-2$if$and/$true){$from}/$is/=!:uuid:2222
(=!:uuid:2222/=!:uuid:1111)($push[$do]*!:uuid:d-2$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

</section>

<section id="s.standard.deferred.push.link.contract.template"><title>Standard Deferred Push Link Contract Template</title>

<para>The purpose of the <firstterm>standard deferred push link contract template</firstterm> is to
instantiate deferred push link contracts with a <code>$push</code> permission on a certain subgraph identified by
the <code>{$push}</code> variable.</para>

<para>Its policy authorizes messages only from a single specific requester and requires a valid signature.</para>

<para>The <firstterm>standard push link contract template</firstterm> is instantiated automatically every time a
request operation is <glossterm>deferred</glossterm> (see <xref linkend="s.response.message.deferred.push.contracts"/>).</para>

<para>The <firstterm>standard deferred push link contract template</firstterm> is typically instantiated as an instance in a <code>[$do]</code>
entity collection, since
for any given relationship between two peers, multiple <firstterm>push link contracts</firstterm> may exist.</para>

<para>The <firstterm>standard deferred push link contract template</firstterm>:</para>

<programlisting>$defer$push{$do}/$push/{$push}
$defer$push{$do}/$is()/{($from)}
($defer$push{$do}$if$and/$true){{$from}}/$is/{$to}
($defer$push{$do}$if$and/$true){{$msg}}&lt;$sig>&lt;$valid>/&amp;/true
($defer$push{$do}$if$and/$true){{$msg}}/$is$msg/{$msg}
</programlisting> 

<para>Example instantiated <firstterm>deferred push link contract</firstterm>:</para>

<programlisting>(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2/$push/=!:uuid:2222&lt;#email>
(=!:uuid:2222/=!:uuid:1111)$defer$push[$do]*!:uuid:d-2/$is()/(=!:uuid:1111)
(=!:uuid:2222/=!:uuid:1111)($defer$push[$do]*!:uuid:d-2$if$and/$true){$from}/$is/=!:uuid:2222
(=!:uuid:2222/=!:uuid:1111)($defer$push[$do]*!:uuid:d-2$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
(=!:uuid:2222/=!:uuid:1111)($defer$push[$do]*!:uuid:d-2$if$and/$true){$msg}/$is$msg/=!:uuid:1111[$msg]*!:uuid:m-1
</programlisting>

</section>

<section id="s.standard.digest.link.contract.template"><title>Standard Digest Link Contract Template</title>

<para>The purpose of the <firstterm>standard digest link contract template</firstterm> is to
instantiate digest link contracts that only authorize a single specific message. This is achieved
through a policy that requires a certain digest value calculated from the serialized message.</para>

<para>The <firstterm>standard digest link contract template</firstterm> is typically instantiated as an instance in a <code>[$do]</code>
entity collection, since
for any given relationship between two peers, multiple <firstterm>digest link contracts</firstterm> may exist.</para>

<para>The <firstterm>standard digest link contract template</firstterm>:</para>

<programlisting>$msg$digest{$do}/$all/
($msg$digest{$do}$if/$true){{$msg}}&lt;$digest>/{&amp;}/{&lt;$digest>}</programlisting>

</section>

</appendix>

<appendix id="a.standard.message.templates" role="normative"><title>Standard Message Templates</title>

<para>The message templates defined in this section MUST be recognized by XDI processors
to be part of the common graph. They can be used for <glossterm>message instantiation</glossterm>
(see <xref linkend="s.message.instantiation"/>).</para>

<section id="s.standard.get.message.template"><title>Standard Get Message Template</title>

<para>The purpose of the <firstterm>standard get message template</firstterm> is to
execute a <code>$get</code> operation on a certain subgraph identified by the
<code>{$get}</code> variable.</para>

<para>The <firstterm>standard get message template</firstterm>:</para>

<programlisting>$get{$msg}/$get/{$get}
</programlisting>

<para>Example instantiated <firstterm>get message</firstterm>:</para>

<programlisting>=!:uuid:1111[$msg]*!:uuid:m-1$do/$get/=!:uuid:2222&lt;#email>
</programlisting>

</section>

</appendix>

<appendix id="a.common.link.contract.patterns" role="non-normative"><title>Common Link Contract Patterns</title>

<para>EDITORIAL NOTE: This section should be moved to <xref linkend="xdi-policy-1.0"/>.</para>

<para>This section describes a number of non-normative link contract patterns that build on the various permissions defined by
this specification. These patterns are designed for various common data sharing and communication use cases.</para>

<section id="s.root.link.contract"><title>Root Link Contract</title>

<para>A <firstterm>root link contract</firstterm> contains a <code>$all</code> permission on 
an entire graph ("root access").</para>

<para>A root link contract is typically set up for the following reasons:</para>

<orderedlist>
<listitem><para>By a peer for itself, in order to give an XDI actor root access to its own graph for
which it is authoritative.</para></listitem>
<listitem><para>Between peers if they have a highly trusted relationship similar
to the legal concepts of custodianship or guardianship (e.g. parent-child).</para></listitem>
<listitem><para>Between XDI agents and XDI endpoints, if they are controlled by the same XDI actor.</para></listitem>
</orderedlist>

<para>A root link contract is an instance of the standard root link contract template
(see <xref linkend="s.standard.root.link.contract.template"/>).</para>

<para>Example root link contract:</para>

<programlisting>(=!:uuid:1111/=!:uuid:1111)$do/$all/
(=!:uuid:1111/=!:uuid:1111)($do$if$and/$true){$from}/$is/=!:uuid:1111
(=!:uuid:1111/=!:uuid:1111)($do$if$and$or/$true){$msg}&lt;$secret>&lt;$token>&lt;$valid>/&amp;/true
(=!:uuid:1111/=!:uuid:1111)($do$if$and$or/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
</programlisting>

</section>

<section id="s.public.link.contract"><title>Public Link Contract</title>

<para>A <firstterm>public link contract</firstterm> contains a <code>$get</code> permission on 
certain limited subgraphs that are intended to be public.</para>

<para>A public link contract does not contain a policy, i.e. it always evaluates to <emphasis>true</emphasis>.</para>

<para>Example public link contract:</para>

<programlisting>(=!:uuid:1111/$public)($do/$get)=!:uuid:1111/$is$ref/{}
(=!:uuid:1111/$public)($do/$get)/$is$ref/{}
(=!:uuid:1111/$public)$do/$get/=!:uuid:1111$public
(=!:uuid:1111/$public)$do/$get/=!:uuid:1111$msg$sig$keypair&lt;$public>&lt;$key>
(=!:uuid:1111/$public)$do/$get/=!:uuid:1111$msg$encrypt$keypair&lt;$public>&lt;$key>
(=!:uuid:1111/$public)($do/$get)=!:uuid:1111$msg$sig$keypair/$is#/{}
(=!:uuid:1111/$public)($do/$get)=!:uuid:1111$msg$encrypt$keypair/$is#/{}
</programlisting>

</section>

<section id="s.connect.link.contract"><title>Connect Link Contract</title>

<para>A <firstterm>connect link contract</firstterm> contains a <code>$connect</code> permission on
an entire graph (see <xref linkend="s.operation.connect"/>).</para>

<para>A connect link contract contains policies that will defer all request operations.</para>

<para>Example connect link contract:</para>

<programlisting>(=!:uuid:1111/$connect)$do/$connect/
(=!:uuid:1111/$connect)($do$defer$push$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
(=!:uuid:1111/$connect)$do$if//$not
</programlisting>

</section>

<section id="s.send.link.contract"><title>Send Link Contract</title>

<para>A <firstterm>send link contract</firstterm> contains a <code>$send</code> permission on
an entire graph (see <xref linkend="s.operation.send"/>).</para>

<para>A send link contract contains policies that will defer all request operations.</para>

<para>Example send link contract:</para>

<programlisting>(=!:uuid:1111/$send)$do/$send/
(=!:uuid:1111/$send)($do$defer$push$if$and/$true){$msg}&lt;$sig>&lt;$valid>/&amp;/true
(=!:uuid:1111/$send)$do$if//$not
</programlisting>

</section>

</appendix>

<appendix id="a.common.messaging.patterns" role="non-normative"><title>Common Messaging Patterns</title>

<para>This section describes a number of non-normative messaging patterns that build on the various operations defined by
this specification. These patterns are designed for various common data sharing and communication use cases.</para>

<section id="a.common.messaging.patterns.invitations"><title>Invitations</title>

<para>An <firstterm>invitation</firstterm> is a <code>$send</code> request operation with an inner message whose
responder is equal to the requester of outer message. In other words, it is a way for a requester to "invite"
a responder to send a request back to the original requester.</para>

<para>The requester of the <code>$send</code> operation (and thus the responder of the inner message) is called
<firstterm>inviting peer</firstterm> (or short <firstterm>inviter</firstterm>). The responder of the
<code>$send</code> operation (and thus the requester of the inner message) is called
<firstterm>invited peer</firstterm> (or short <firstterm>invitee</firstterm>).</para>

<para>In many cases, the inner message contains a <code>$connect</code> request operation. This enables a requester to "invite"
a responder to send a request for a new link contract to the original requester.</para>

<para>The invitation typically references the invitee's <glossterm>send link contract</glossterm> (see <xref linkend="s.send.link.contract"/>).</para>

<para>The inviter typically sets up an instance of the <glossterm>standard digest link contract template</glossterm>
 (see <xref linkend="s.standard.digest.link.contract.template"/>) to ensure that the inner message &#8211; if accepted by
 the invitee &#8211; is authorized when received by the inviter.</para>

<para>Example digest link contract instance set up by the inviter:</para>

<programlisting>(=!:uuid:1111/=!:uuid:2222)$msg$digest$do/$all/
(=!:uuid:1111/=!:uuid:2222)($msg$digest$do$if/$true){$msg}&lt;$digest>/&amp;/"...digest..."
</programlisting>

<para>Example invitation from inviter <code>=!:uuid:1111</code> to invitee <code>=!:uuid:2222</code>:</para>

<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1/$do/(=!:uuid:2222/$send)$do
(=!:uuid:1111[$msg]*!:uuid:m-1/$send)=!:uuid:2222[$msg]*!:uuid:m-2/$is()/(=!:uuid:1111)
(=!:uuid:1111[$msg]*!:uuid:m-1/$send)=!:uuid:2222[$msg]*!:uuid:m-2/$do/(=!:uuid:1111/=!:uuid:2222)$msg$digest$do
(=!:uuid:1111[$msg]*!:uuid:m-1/$send)=!:uuid:2222[$msg]*!:uuid:m-2/$connect/$get{$do}
(=!:uuid:1111[$msg]*!:uuid:m-1/$send)=!:uuid:2222[$msg]*!:uuid:m-2$connect{$get}/$is/=!:uuid:1111&lt;#email>
</programlisting>

</section>

<section id="a.common.messaging.patterns.impersonation"><title>Impersonation</title>

<para>An <firstterm>impersonation</firstterm> is a <code>$send</code> request operation with an inner message whose
requester is different from the responder of the outer message. In other words, it is a way for a requester to ask
a responder to "impersonate" an arbitrary peer when sending the inner message.</para>

</section>

<section id="a.common.messaging.patterns.approval"><title>Approval of a Deferred Request Operation</title>

<para>If a request operation is deferred due to link contract policy (see <xref linkend="xdi-policy-1.0"/>),
it can be <firstterm>approved</firstterm>
by "re-sending" the it as an inner message of a new <code>$send</code> request operation.
The outer message of the <code>$send</code> operation is called <firstterm>approval message</firstterm>.</para>

<para>The responder of an outer message (the approval message) is equal to responder of the inner message
(the deferred message).</para>

<para>In many cases, the requester and responder of an approval message are equal, and the
<glossterm>root link contract</glossterm> is used. In other words, an XDI actor approves a deferred message
that was sent to its own graph.</para>

<para>Note that the approval message will trigger the push <glossterm>deferred push contract</glossterm>
(see <xref linkend="xdi-policy-1.0"/>) that
was automatically created for the deferred request operation.</para>

<para>Example request message deferred due to link contract policy:</para>

<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1/$do/(=!:uuid:2222/=!:uuid:1111)$get[$do]*!:uuid:
=!:uuid:1111[$msg]*!:uuid:m-1$do/$connect/$get{$do}
=!:uuid:1111[$msg]*!:uuid:m-1$connect{$get}/$is/=!:uuid:2222&lt;#email>
</programlisting>

<para>Example approval message:</para>

<programlisting>(=!:uuid:1111)/$send/=!:uuid:1111[$msg]*!:uuid:m-1
=!:uuid:1111[$msg]*!:uuid:m-1/$is()/(=!:uuid:2222)
=!:uuid:1111[$msg]*!:uuid:m-1/$do/(=!:uuid:2222/=!:uuid:1111)$get[$do]*!:uuid:
=!:uuid:1111[$msg]*!:uuid:m-1$do/$connect/$get{$do}
=!:uuid:1111[$msg]*!:uuid:m-1$connect{$get}/$is/=!:uuid:2222&lt;#email>
</programlisting>

</section>

<section id="a.common.messaging.patterns.rejection"><title>Rejection of a Deferred Request Operation</title>

<para>If a request message is deferred due to link contract policy</para>

<para>Example </para>

</section>

<section><title>Delegation</title>

<para>TODO: Describe how one peer can be a delegate of another peer.</para>
<para>TODO: Common example is an XDI agent acting as a delegate of an XDI endpoint.</para>
<para>TODO: Maybe mention app clouds and app instances and app sessions.</para>

</section>

</appendix>

</article>
