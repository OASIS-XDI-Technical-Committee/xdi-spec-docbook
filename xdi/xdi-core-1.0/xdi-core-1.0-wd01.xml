<?xml version="1.0" encoding="UTF-8"?>
<!-- 
For use when a committee document points at the OASIS web site for publishing:
<?xml-stylesheet type="text/xsl" 
href="http://docs.oasis-open.org/templates/DocBook/spec-0.6/stylesheets/oasis-specification-html.xsl"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
         "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" 

For use when a committee document points to an embedded runtime installation:
<?xml-stylesheet type="text/xsl" 
         href="htmlruntime/spec-0.6/stylesheets/oasis-specification-html.xsl"?>
<!DOCTYPE article
 PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
        "htmlruntime/spec-0.6/docbook/docbookx.dtd" 

For use when a committee document is published in a local environment only
(note the instructions for local publishing require adjusting the stylesheet
 and DocBook directories in these declarations):
<?xml-stylesheet type="text/xsl" 
href="file:///Users/user/xdi-spec-docbook/htmlruntime/spec-0.6/stylesheets/oasis-specification-html-offline.xsl"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
         "file:///c:/oasis/spec-0.6/docbook/docbookx.dtd" 
-->
<?xml-stylesheet type="text/xsl" 
href="http://xdi.org/xdi-spec-docbook/htmlruntime/spec-0.6/stylesheets/oasis-specification-html-offline.xsl"?>
<!DOCTYPE article
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
         "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" 
[
<!--the document properties-->
<!ENTITY name "xdi-core">
<!ENTITY pversion "0.1">
<!ENTITY version "1.0">
<!ENTITY stage "wd01">
<!ENTITY standard "Working Draft 01">
<!ENTITY this-loc "http://docs.oasis-open.org/xdi/spec-&version;">
<!ENTITY previous-loc "http://docs.oasis-open.org/xdi/spec-&pversion;">
<!ENTITY latest-loc "http://docs.oasis-open.org/xdi/spec">
<!ENTITY pubdate "25 November 2013">
<!ENTITY title "XDI Core V&version;">
]>
<article status="&standard;">

<articleinfo>
<title>&title;</title>

<productname>&name;</productname>
<productnumber>&version;-&stage;</productnumber>
<releaseinfo role="track">Standards Track Work Product</releaseinfo>

<releaseinfo role="OASIS-specification-this-authoritative">&this-loc;/&name;-&version;-&stage;.xml</releaseinfo>
<releaseinfo role="OASIS-specification-this">&this-loc;/&name;-&version;-&stage;.pdf</releaseinfo>
<releaseinfo role="OASIS-specification-this">&this-loc;/&name;-&version;-&stage;.html</releaseinfo>

<releaseinfo role="OASIS-specification-previous-authoritative">&previous-loc;/&name;-&pversion;.xml</releaseinfo>
<releaseinfo role="OASIS-specification-previous">&previous-loc;/&name;-&pversion;.pdf</releaseinfo>
<releaseinfo role="OASIS-specification-previous">&previous-loc;/&name;-&pversion;.html</releaseinfo>

<releaseinfo role="OASIS-specification-latest-authoritative">&latest-loc;/&name;.xml</releaseinfo>
<releaseinfo role="OASIS-specification-latest">&latest-loc;/&name;.pdf</releaseinfo>
<releaseinfo role="OASIS-specification-latest">&latest-loc;/&name;.html</releaseinfo>

<releaseinfo role="committee"><ulink url="http://www.oasis-open.org/committees/xdi">OASIS XDI TC</ulink></releaseinfo>

<authorgroup>
  <editor>
    <firstname>Joseph</firstname><surname>Boyle</surname>
    <affiliation><orgname>Planetwork</orgname></affiliation>
    <email>joseph@planetwork.net</email>
  </editor>
  <editor>
    <firstname>Drummond</firstname><surname>Reed</surname>
    <affiliation><orgname>XDI.org</orgname></affiliation>
    <email>drummond.reed@xdi.org</email>
  </editor>
  <editor>
    <firstname>Markus</firstname><surname>Sabadello</surname>
    <affiliation><orgname>XDI.org</orgname></affiliation>
    <email>markus.sabadello@xdi.org</email>
  </editor>
</authorgroup>

<pubdate>&pubdate;</pubdate>

<copyright><year>2013</year>
<holder>OASIS Open, Inc. All Rights Reserved.</holder></copyright>

<legalnotice role="additional"><title>Additional artifacts</title>
<para>This prose specification is one component of a Work Product which also includes:</para>
<itemizedlist spacing="compact">
<listitem><para>
publishing materials: <ulink url="&this-loc;/&name;-&version;-&stage;.zip">&this-loc;/&name;-&version;-&stage;.zip</ulink></para>
</listitem>
</itemizedlist>
</legalnotice>

<legalnotice role="related"><title>Related work</title>
  <para>This document is primarily based on a set of proposals that had been collected by the OASIS XDI TC on its associated wiki at <ulink url="https://wiki.oasis-open.org/xdi/">https://wiki.oasis-open.org/xdi/</ulink>.</para>
</legalnotice>

<abstract><title>Abstract</title>
  <para>This working draft specifies the abstract pattern for all XDI core together with the binding to the http/https protocol for performing XDI operations using XDI messages.</para>
</abstract>

<!--legalnotice role="status"><title>Status</title>
<para>This is a work in progress contributed to the OASIS TC administration 
and does not at this time represent the consensus of any particular OASIS Technical Committee.
There are no plans to make this a formal Committee Specification as it is merely an internal
document made available to committee members to support the publishing process.</para>
</legalnotice-->

<legalnotice role="citation"><title>Citation format</title>
<para>When referencing this specification the following citation format should be used:</para>
<bibliolist>
<bibliomixed>
  <abbrev>OASIS-XDI-Core-V1.0</abbrev>
  <title>OASIS XDI Core V1.0</title>
  <date>&pubdate;. </date>
  <releaseinfo>OASIS &standard;. </releaseinfo>
  <citetitle><ulink url="&latest-loc;/&name;.html">&latest-loc;/&name;.html</ulink>.</citetitle>
</bibliomixed>
</bibliolist>
</legalnotice>
<legalnotice role="notices"><title>Notices</title>
<para>Copyright &#169; OASIS&#174; Open 2013. All Rights Reserved. 
</para>
<para>All capitalized terms in the following text have the meanings assigned to them in the OASIS Intellectual Property Rights Policy (the "OASIS IPR Policy"). The full Policy may be found at <ulink  url="http://www.oasis-open.org/who/intellectualproperty.php">http://www.oasis-open.org/who/intellectualproperty.php</ulink>.</para>
<para>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published, and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this section are included on all such copies and derivative works. However, this document itself may not be modified in any way, including by removing the copyright notice or references to OASIS, except as needed for the purpose of developing any document or deliverable produced by an OASIS Technical Committee (in which case the rules applicable to copyrights, as set forth in the OASIS IPR Policy, must be followed) or as required to translate it into languages other than English.</para> 
<para>The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns.</para>
<para>This document and the information contained herein is provided on an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY OWNERSHIP RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</para> 
<para>OASIS requests that any OASIS Party or any other party that believes it has patent claims that would necessarily be infringed by implementations of this OASIS Committee Specification or OASIS Standard, to notify OASIS TC Administrator and provide an indication of its willingness to grant patent licenses to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification.</para>
<para>OASIS invites any party to contact the OASIS TC Administrator if it is aware of a claim of ownership of any patent claims that would necessarily be infringed by implementations of this specification by a patent holder that is not willing to provide a license to such patent claims in a manner consistent with the IPR Mode of the OASIS Technical Committee that produced this specification. OASIS may include such claims on its website, but disclaims any obligation to do so.</para>
<para>OASIS takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS' procedures with respect to rights in any document or deliverable produced by an OASIS Technical Committee can be found on the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this OASIS Committee Specification or OASIS Standard, can be obtained from the OASIS TC Administrator. OASIS makes no representation that any information or list of intellectual property rights will at any time be complete, or that any claims in such list are, in fact, Essential Claims.</para>
<para>The name "OASIS" is a trademark of <ulink url="http://www.oasis-open.org">OASIS</ulink>, the owner and developer of this specification, and should be used only to refer to the organization and its official outputs. OASIS welcomes reference to, and implementation and use of, specifications, while reserving the right to enforce its marks against misleading uses. Please see <ulink url="http://www.oasis-open.org/who/trademark.php">http://www.oasis-open.org/who/trademark.php</ulink> for above guidance.</para>
</legalnotice>
</articleinfo>


<section><title>About</title><para>About</para></section>

<section id="s.introduction">
<title>Introduction</title>

  <para>This working draft specifies the XDI graph model and serializations.</para>

<para></para>

<section>
  <title>Terminology</title>
  <section>
    <title> Key words</title>
    <para>The key words <glossterm>must</glossterm>, <glossterm>must not</glossterm>, <glossterm>required</glossterm>,
      <glossterm>shall</glossterm>, <glossterm>shall not</glossterm>, <glossterm>should</glossterm>, <glossterm>should not</glossterm>,
      <glossterm>recommended</glossterm>, <glossterm>may</glossterm>, and <glossterm>optional</glossterm> are to be
      interpreted as described in <xref linkend="rfc2119"/>. Note that for reasons of style, these words are not capitalized in this
      document.</para>
  </section>
</section>

<section>
  <title>Normative References</title>
  <bibliolist>
    <bibliomixed id="xdi-messaging-1.0">
      <abbrev>OASIS-XDI-Messaging-V1.0</abbrev>
      <title><ulink url="../../xdi-messaging-1.0/xdi-messaging-1.0-wd01.xml">OASIS XDI 1.0 Messaging Specification</ulink></title>
      <author><firstname>Markus </firstname>
        <surname>Sabadello</surname></author>,
      <author><firstname>Drummond </firstname>
        <surname>Reed</surname></author>. 
      <date>&pubdate;. </date>
      <releaseinfo>OASIS &standard;. </releaseinfo>
      <citetitle><ulink url="&latest-loc;/xdi-messaging.html">&latest-loc;/xdi-messaging.html</ulink>.</citetitle>
    </bibliomixed>
    <bibliomixed id="rfc2119">
      <abbrev>RFC 2119</abbrev>
      <title><ulink url="http://www.ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</ulink></title>
      <date>March 1997</date>
      <author><firstname>S. </firstname>
        <surname>Bradner</surname></author>. 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed>
    <bibliomixed id="rfc2234">
      <abbrev>RFC 2234</abbrev>
      <title><ulink url="http://www.ietf.org/rfc/rfc2234.txt">Augmented BNF for Syntax Specifications: ABNF</ulink></title>
      <date>November 1997</date>
      <author><firstname>D. </firstname>
        <surname>Crocker</surname></author>,
      <author><firstname>P. </firstname>
        <surname>Overell</surname></author>. 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed>
    <bibliomixed id="rfc4627">
      <abbrev>RFC 4627</abbrev>
      <title><ulink url="http://www.ietf.org/rfc/rfc4627.txt">The application/json Media Type for JavaScript Object Notation (JSON)</ulink></title>
      <date>July 2006</date>
      <author><firstname>D. </firstname> 
        <surname>Crockford</surname></author>. 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed>
    <bibliomixed id="rfc4122">
      <abbrev>RFC 4122</abbrev>
      <title><ulink url="http://www.ietf.org/rfc/rfc4122.txt">A Universally Unique IDentifier (UUID) URN Namespace</ulink></title>
      <date>July 2005</date>
      <author><firstname>D. </firstname> 
        <surname>Crockford</surname></author>. 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed>
    <bibliomixed id="rfc5952">
      <abbrev>RFC 5952</abbrev>
      <title><ulink url="http://www.ietf.org/rfc/rfc5952.txt">A Recommendation for IPv6 Address Text Representation</ulink></title>
      <date>August 2010</date>
      <author><firstname>S. </firstname>
        <surname>Kawamura</surname></author>, 
      <author><firstname>M. </firstname>
        <surname>Kawashima</surname></author>. 
      <releaseinfo>IETF (Internet Engineering Task Force)</releaseinfo>
    </bibliomixed>
    <bibliomixed id="fips180-4">
      <abbrev>FIPS 180-4</abbrev>
      <title><ulink url="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</ulink></title>
      <date>March 2012</date>
      <author><firstname></firstname>
        <surname></surname></author>
      <releaseinfo>Federal Information Processing Standards Publication (FIPS), NIST</releaseinfo>
    </bibliomixed>
  </bibliolist>
</section>

<section>
  <title>Non-Normative References</title>
  <bibliolist>
    <bibliomixed id="erm">
      <abbrev>erm</abbrev>
      <title><ulink url="https://en.wikiversity.org/wiki/1976/Chen">The Entity-Relationship Model: Toward a Unified View of Data</ulink></title>
      <date>1976</date>
      <author><firstname>Peter </firstname>
        <surname>Chen</surname></author>.
      <releaseinfo>ACM Transactions on Database Systems 1(1): 9–36. doi:10.1145/320434.320440</releaseinfo>
    </bibliomixed>
    <bibliomixed id="json-ld">
      <abbrev>json-ld</abbrev>
      <title><ulink url="http://json-ld.org/spec/latest/json-ld">JSON-LD: A JSON-based Serialization for Linked Data</ulink></title>
      <date>04 October 2013</date>
      <author><firstname>Gregg </firstname>
        <surname>Kellogg</surname></author>,
      <author><firstname>Markus </firstname>
        <surname>Lanthaler</surname></author>,
      <author><firstname>Niklaus </firstname>
        <surname>Lindström</surname></author>,
      <author><firstname>Dave </firstname>
        <surname>Longley</surname></author>,
      <author><firstname>Manu </firstname>
        <surname>Sporny</surname></author>. 
      <releaseinfo>W3C Editor's Draft 04 October 2013 </releaseinfo>
    </bibliomixed>
  </bibliolist>
</section>

</section>
  <section><title>Design Goals</title><para>This section communicates the design goals that have guided the development of XDI.</para>
    <section><title>100% Addressability</title>
      <para>You can address any node in the graph. Uniquely, unlike RDF.</para></section>
    <section><title>No Central Authority</title>
      <para>Peer to peer graph model is possible but not compulsory</para></section>
    <section><title>Contextual Identification</title>
      <para>Ability to address context is built into the graph. Arcs can carry semantic value.</para></section>
    <section><title>Persistent Identification</title>
      <para>The ability to have nodes in the graph whose address will not change over time or be reused.</para></section>
    <section><title>Serialization Independence</title>
      <para>The graph model is not bound to a particular serialization format. Different serializations can be used as appropriate.</para></section>
    <section><title>Portability</title>
      <para>Instance of the graph can be moved to other locations on the net and still maintain 100% of their semantics.</para></section>
    <section><title>Authorization and Policy Expression</title>
      <para>Authorization and Policy expression can be modeled in the graph to govern rights or access to data.</para></section>
    <section><title>Schema and Ontology Expression</title>
      <para>Schema requirements and Ontological concepts can be modeled in the graph for use in the graph. </para></section>
    <section><title>Extensibility</title>
      <para></para></section>
  </section>
  <section><title>The XDI Graph Model</title><para></para>
    <section><title>Overview</title>
      <para>The XDI graph is a directed acyclic graph with nodes connected by arcs. An XDI path is a connected chain of successive arcs; it forms an address designating the node at the end of the arc chain.</para></section>
    <section><title>Nodes</title>
      <para>There are four basic node types:</para>
      <section><title>Root ( )</title>
        <para></para></section>
        <svg width="260" height="160" version="1.1" xmlns="http://www.w3.org/2000/svg">
        <g transform="translate(30,30)" text-anchor="middle" dominant-baseline="middle">
           <g transform="translate(0,0)">
             <circle r="15" stroke="black" fill="white"/>
             <text fill="black" dominant-baseline="middle">r</text>
             <path d="M15 0 h70" stroke="black"/>
             <path d="M85 0 l-8 -4 v8 l8 -4 Z" stroke="black"/>
           </g>
           <g transform="translate(100,0)">
             <circle r="15" stroke="black" fill="red"/>
             <text fill="white" dominant-baseline="middle">s</text>
             <path d="M0 15 v70" stroke="black"/>
             <path d="M0 85 l-4 -8 h8 l-4 8 Z" stroke="black"/>
           </g>
           <g transform="translate(100,100)">
             <path d="M0 -15 L-20 0 L0 15 L20 0 Z" stroke="black" fill="green"/>
             <text fill="white" dominant-baseline="middle">n</text>
             <path d="M20 0 h60" stroke="black"/>
             <path d="M80 0 l-8 -4 v8 l8 -4 Z" stroke="black"/>
           </g>
           <g transform="translate(200,100)">
             <path d="M0 -15 L-20 0 L0 15 L20 0 Z" stroke="black" fill="white"/>
             <text fill="black" dominant-baseline="middle">x</text>
             <path d="M0 -15 v-75" stroke="black" stroke-dasharray="2 2"/>
             <path d="M0 -90 l-4 8 h8 l-4 -8 Z" stroke="black"/>
           </g>
           <g transform="translate(200,0)">
             <text fill="black" dominant-baseline="middle">"value"</text>
           </g>
           <g transform="translate(0,100)">
             <rect x="-15" y="-10" width="30" height="20" stroke="black" fill="blue"/>
             <text fill="white" dominant-baseline="middle">e</text>
           </g>
           <g transform="translate(0,0)">
             <path d="M0 15 v75" stroke="black" stroke-dasharray="7 7"/>
             <path d="M0 90 l-4 -8 h8 l-4 8 Z" stroke="black"/>
           </g>
        </g>
        <!-- Show outline of canvas using 'rect' element -->
        <rect x="0" y="0" width="260" height="160" fill="none" stroke="black" stroke-width=".02cm" />
      </svg>
        
      <section><title>Entity</title>
        <para></para></section>
      <section><title>Attribute &lt; &gt;</title>
        <para></para></section>
      <section><title>Value &amp;</title>
        <para></para></section>
    </section>
    <section><title>Arcs</title>
      <para>Arcs in the XDI graph consist of an identifier with one or more context symbols or functions attached.</para>
      <section><title>Literal</title>
        <para>These are terminal and can only lead to a value node</para></section>
      <section><title>Contextual</title>
        <para>These express most of the XDI graph, with each arc in a path representing a specialization.</para></section>
      <section><title>Relational</title>
        <para>These specify equivalence or other relations between two nodes. When represented as statements, the two nodes are the subject and object of the statement, while the relation is the predicate.</para></section>
    </section>
  </section>
  <section><title>Node Types</title>
    <para>There are four (five?) types: value, variable, root, and subgraph.</para>
    <section><title>Literal &amp;</title>
      <para>Leaf node carrying literal data value. Syntax is &amp; (as predicate arc)</para></section>
    <section><title>Value &amp;</title>
      <para>Node identifying the value of an attribute. Syntax is &amp; (as final arc of a subject path)</para></section>
    <section><title>Root ( )</title>
      <para>An XDI graph starts at the outer root, whose XDI address is <code>()</code>. An XDI (address) path may start with zero, one, or multiple root expressions. Roots are enclosed in parentheses.</para>
      <section><title>Outer ()</title>
        <para>The outer root roots the whole graph and is expressed as ().</para></section>
      <section><title>Peer (S)</title>
        <para>This contains an XDI address, or an IRI.</para></section>
      <section><title>Inner (S/P)</title>
        <para>Inner root consists of a subject and predicate</para></section>
      <section><title>Statement (S/P/O)</title>
        <para>This contains an entire XDI statement, i.e. a triple of subject/predicate/object.</para></section>
    </section>
    <section><title>Singleton</title><para>A single instance of a class</para>
      <section><title>Entity</title><para>Entity</para></section>
      <section><title>Attribute</title><para>Enclosing in angle brackets &lt; &gt; indicates an attribute as opposed to an entity.</para></section>
    </section>
    <section><title>Collection [ ]</title><para>Collection</para>
       <section><title>Entity</title>
         <para>An entity may contain entities and attributes but cannot directly contain a value. Enclosing in brackets [ ] indicates a collection as opposed to a singleton.</para></section>
       <section><title>Attribute</title>
         <para>An attribute may only contain subattributes (and, if singular, a value)</para></section>
    </section>
    <section><title>Member # !</title>
      <para>A node identifying an instance of an entity or attribute within a collection</para>
      <section><title>Entity</title><para>Entity</para></section>
      <section><title>Attribute</title><para>Attribute</para></section>
    </section>
    <section><title>Definition +</title><para>XDI dictionary definition</para>
      <section><title>Entity</title><para>Entity</para></section>
      <section><title>Attribute</title><para>Attribute</para></section>
    </section>
    <section><title>Variable { }</title> 
      <para>This syntax can enclose any other node type. To be further defined.</para></section>
  </section>
  <section><title>Namespace Symbols</title><para>Formerly Context Symbols</para>
    <section><title>Authorities</title>
      <para>Authorities</para>
      <section><title>Personal =</title>
        <para>Natural persons</para></section>
      <section><title>Legal @</title>
        <para>Groups, organizations, or other entities in whose identities legal rights may be asserted</para></section>
      <section><title>General *</title>
        <para>Entities in whose identities legal rights may not be asserted</para></section>
    </section>
    <section><title>Classes</title><para>Classes</para>
      <section><title>Reserved $</title>
        <para>XDI grammar and keywords use "dollar words".</para></section>
      <section><title>Unreserved +</title>
        <para>XDI generic dictionary words for user use.</para></section>
    </section>
    <section><title>Instances</title><para>Instances</para>
      <section><title>Ordered #</title>
        <para>Zero-based numeric order</para></section>
      <section><title>Unordered !</title>
        <para>Unordered </para></section>
    </section>
  </section>
  <section><title>Equivalence Relations</title><para>These are indicated by relational arcs.</para>
    <section><title>Identity $is</title>
      <para>$is indicates complete equivalence.</para></section>
    <section><title>Reference $ref</title>
      <para>$ref indicates the subject is a reference pointing to the object</para></section>
    <section><title>Replacement $rep</title>
      <para>$rep indicates the subject not only stands for the object, but that the reference should be replaced with the object.</para></section>
  </section>
  <section><title>XDI Graph and Statement Grammars</title>
    <para>Grammars are given in Augmented Backus-Naur Form as defined in <xref linkend="rfc2234"/>. Slash / is alternation, parentheses are grouping, * means zero or more of following, 1* means one or more of following, brackets [] mean zero or one of following, i.e. optional.</para>
    <para>XDI values are JSON values, and the JSON grammar is included for non-normative reference.</para>
    <section><title>Delimiter Grammar</title>
    <para>XDI statements' grammar is defined on a level independent of serialization, using generic delimiter symbols. In the following section, each specific statement serialization is then defined by adding a small grammar defining its delimiters. These symbols in all capital letters are the generic delimiters:.</para>
<programlisting>
STMTSL,R: Before and after a list of statements
STMTSN:   Between statements in a list of statements
STMTL,R:  Before and after a statement
OBJSL,R:  Before and after a list of objects, for serializations allowing multiple objects for one subject/predicate
OBJSN:    Between objects in a list of objects
S-P, P-O: Between subject, predicate, and object of a statement
C-I:      Between a context symbol and the following identifier
</programlisting>

    </section>
    <section><title>Statement Grammar</title>
      <para>Three types of statements are defined here: contextual statements, relational statements, and literal statements. </para>
      <para>Contextual statements assert a relative address (the statement's object) starting from a given node (the statement's subject) The statement can only be valid if the concatenation of the subject and object (or object and subject, for an inverse contextual statement) is a valid XDI path according to the Path Grammar below: proceeding from peer roots to inner roots, then entities, then attributes, then optionally to value. Also, if the object starts with a member specifier, then the subject must end with a collection specifier. </para>
      <para>Direct contextual statements have the empty string as their predicate, so therefore appear as subject//object.  The concatenated address can be constructed simply by removing the //. Put another way, given an XDI address, we can cut it placing // between two of its arcs, and get a contextual statement asserting the second part's existence as a relative address starting at the context node definid by the first part. </para>
      <para>Currently only contextual statements are allowed to have multiple objects in the multiple-object serializations. (Check assumption that relational statements cannot have multiple objects)</para>

<programlisting>
xdi-statement-list   = STMTSL [ xdi-statement *( STMTSN xdi-statement ) ] STMTSR
xdi-statement        = STMTL ( contextual-statement / relational-statement / literal-statement ) STMTR
contextual-statement = direct-contextual / inverse-contextual
relational-statement = direct-relational / inverse-relational
direct-contextual    =   xdi-address S-P                     P-O   xdi-addresses
inverse-contextual   =   xdi-address S-P "$is" "()"          P-O   xdi-addresses
direct-relational    =   xdi-address S-P       xdi-predicate P-O xrefs-addresses
inverse-relational   =  xref-address S-P "$is" xdi-predicate P-O   xdi-address
literal-statement    = value-address S-P       "&amp;"       P-O  json-value
</programlisting>
   <para>XDI values are JSON values with JSON syntax; the JSON grammar is included at the end of this sectionfor non-normative reference.</para>
      <para>Here inverse-relational statements appear to be a subset of direct-relational statements, because we are not strongly constraining predicates yet</para>
    </section>

    <section><title>Predicate Grammar</title>
      <para>Most relational predicates will be described in more detail in following specs.</para>
<programlisting>
xdi-predicate   = xdi-equivalence / xdi-operator
xdi-equivalence = $is / [ $is ] $ref / [ $is ] $rep
xdi-operator    = $true / $false / xdi-operation
xdi-operation   = $get / $set / $del / $copy / $move / ( $do [ do-extension ] )
do-extension    = $signal 
xdi-event       = $domain 
xdi-condition   = $equals / $greater / $lesser
</programlisting>
    </section>
    
    <section><title>Address Grammar</title>
      <para>An XDI address can contain peer roots (cross-references), then inner roots, then entities, then attributes, then literal (value), in that order. Each of those elements is optional, except that a value must be preceded by an attribute singleton or attribute member.</para>
      <para>Addresses are interpreted as absolute; that is, they start at the outer root. The initial outer root is not written, except in the special case of the empty path, which is written () instead of as an empty string. This special case is not described in the ABNF as it is not context-free, but is to be implemented in serialization after generation, and deserialization before parsing.</para>
      <para>xdi-addresses is used when multiple objects per subject/predicate pair are used in multiple-line display format or in JSON serialization. For the non-multiple-object serializations, simply use xdi-addresses = xdi-address instead.</para>

<programlisting>
xdi-addresses   = OBJSL [  xdi-address *( OBJSN  xdi-address ) ] OBJSR 
xrefs-addresses = OBJSL [ xref-address *( OBJSN xref-address ) ] OBJSR 
xref-address    = xdi-address / xref
xdi-address     = *xref *inner-root *entity-node *attrib-node [ attrib-value ]
value-address   = *xref *inner-root *entity-node *attrib-node   attrib-value
entity-node     = ( entity-singleton / ( entity-collection [ entity-member ] ) )
attrib-node     = ( attrib-singleton / ( attrib-collection [ attrib-member ] ) ) 
attrib-value    = ( attrib-singleton / ( attrib-collection   attrib-member   ) ) value-arc
</programlisting>
      <para></para>
<programlisting>
</programlisting>
      <para>The outer root is simply the empty string case of xdi-address, so does not appear here.</para>
      <para>Peer roots (xrefs) must occur before inner roots in a xdi-address. (and all roots precede entities, attributes, and values)</para>
      <para>*Statement roots no longer appear as such. Since they can only occur as the object of a relational statement, they are accounted for in the Statement Grammar instead.</para>
<programlisting>
xref        = "(" ( xdi-address / xdi-iri / xdi-name ) ")"
inner-root  = "("   xdi-address S-P xdi-address ")"
</programlisting>
    <para>A root may contain a subject-predicate pair (inner root), or a single XDI path; or a single XDI identifier with no context symbols; or an IRI.</para>
    </section>

    <section><title>Entity Arc Grammar</title>
      <para>These describe an individual directed edge in the XDI graph.</para>
      <para>First, entity definitions:</para>
<programlisting>
entity-singleton     = authority-singleton / type-singleton / general-singleton
authority-singleton  = person-singleton / legal-singleton
type-singleton       = unreserved-type / reserved-type
person-singleton     = "=" C-I ( xdi-name / xref )
legal-singleton      = "@" C-I ( xdi-name / xref )
general-singleton    = "*" C-I ( xdi-name / xref / xdi-scheme )
unreserved-type      = "+" C-I ( xdi-name / xref / xdi-scheme )
reserved-type        = "$" C-I   xdi-name

entity-collection    = authority-collection / type-collection / general-collection
authority-collection = person-collection    / legal-collection
type-collection      = reserved-collection  / unreserved-collection
general-collection   = ordered-collection   / unordered-collection / singleton-collection
person-collection    = COLL             "=" COLR 
legal-collection     = COLL             "@" COLR 
reserved-collection  = COLL   reserved-type COLR
unreserved-collection= COLL unreserved-type COLR
ordered-collection   = COLL             "#" COLR 
unordered-collection = COLL             "!" COLR 
singleton-collection = COLL             "*" COLR 

entity-member        = member 
member               = ordered-member / unordered-member
ordered-member       = "#" C-I ( ( %x31-39 DIGIT ) / "0" )
unordered-member     = "!" C-I ( xdi-name / xref / xdi-scheme )
</programlisting>
      <para>Member indexes are positive integers without leading zeroes, except for 0 itself.</para>
    </section>

    <section><title>Non-Entity Arc Grammar</title>
      <para>Other arc types include attributes, definitions, and variables.</para>  
      <para>Attributes are constructed by enclosing the corresponding entity in attribute delimiters, outside everything but collection delimiters:</para>  
<programlisting>
attrib-singleton  = ATTL C-I type-singleton ATTR
attrib-collection = COLL   attrib-singleton COLR
attrib-member     = ATTL C-I         member ATTR 

definition           = authority-definition / type-definition
type-definition      = entity-definition / attrib-definition
entity-definition    = DEFL C-I   type-singleton DEFR
attrib-definition    = DEFL C-I attrib-singleton DEFR
authority-definition = DEFL C-I   authority-node DEFR
authority-node       = ( authority-singleton / ( authority-collection [ member ] ) )

variable             = VARL [ xdi-address ] VARR
value-arc            = "&amp;"
</programlisting>
      <para>Bracketing delimiters used are:</para>  
<programlisting>
COLL     = "[" 
COLR     = "]"
ATTL     = "&lt;" 
ATTR     = "&gt;" 
DEFL     = "|"
DEFR     = "|"
VARL     = "{" 
VARR     = "}"
</programlisting>
    </section>
    
    <section><title>XDI Scheme Grammar</title>
      <para>XDI schemes define canonical forms of certain classes of XDI identifiers.</para>
      <para>SHA-256, SHA-384, SHA-512 are commonly used to identify SHA-2 digests of those lengths. NIST's definition of SHA-3 is still in progress.</para>
      <para>The canonical form for UUID identifiers follows the canonical form of <xref linkend="rfc4122"/>.</para>
      <para>The canonical form for IPv6 identifiers follows the canonical form of <xref linkend="rfc5952"/>, except that :: compression is not used.</para>
<programlisting>
xdi-scheme   =   xdi-sha-256 / xdi-sha-384 / xdi-sha-512 / xdi-uuid / xdi-ipv6
xdi-sha-256  = ":sha-256:"  64HEX 
xdi-sha-384  = ":sha-384:"  96HEX 
xdi-sha-512  = ":sha-512:" 128HEX 
xdi-uuid     = ":uuid:"      8HEX 4*( "-" 4HEX ) 8HEX
xdi-ipv6     = ":ipv6:"      4HEX 7*( ":" 4HEX )  
</programlisting>
    </section>
    <section><title>Identifier Grammar</title>
      <para>A simple IRI grammar is a lightweight parsing alternative to the full IRI grammar in <xref linkend="rfc4627"/>. An XDI processor MAY check for full compliance with IRI syntax, which may not be necessary unless about to dereference or analyze the IRI. </para>
      <para>Paired "(" and ")" are allowed in IRI body to accomodate IRI schemes like tel: and sms:. </para>
<programlisting>
xdi-iri    = iri-scheme ":" *iri-body
iri-scheme = LOWER *( LOWER / DIGIT ) 
iri-body   = ( "(" iri-body ")" ) / *iri-char
iri-char   = xdi-name-char / context-symbol / iri-delim
iri-delim  = "/" / "?" / "#" / "[" / "]" / "'" / ","

xdi-name   = *xdi-name-char    ; Note: Includes any JSON numbers
</programlisting>
    </section>

    <section><title>Character Class Grammar</title>
      <para>This contains definitions of character classes and endline. </para>
<programlisting>
xdi-name-char  = UPPER / LOWER / DIGIT / "-" / "." / "_" / %x80-EFFFD      ; ISSUE - is there a way to leave high end open?
context-symbol = "!" / "*" / "=" / "@" / "+" / "$"

LOWER          = %x61-7A
UPPER          = %x41-5A
HEX            = DIGIT / %x61-66
DIGIT          = %x30-39
NZDIG          = %x31-39
QUOTE          = %x22
ENDLINE        = %x0D / %x0A / ( %x0D %x0A )
</programlisting>
      <para>Hex digits in ipv6, uuid are lowercase; only the exponent prefix E in JSON numbers is uppercase.</para>
      <para>Policy on unicode characters.</para>
    </section>

    <section><title>JSON Grammar</title>
      <para>Based on <xref linkend="rfc4627"/> syntax diagrams (no actual grammar rules found there) restricted for canonical form (add reference) canonicality restrictions: no + signs, no leading zeros, no trailing zeros on fraction</para>
      <para>Get ABNF from 4427 and/or ECMA</para>
      <para>We use JSON values, i.e. a value may be a single string, number, true, false, or null, not necessarily a JSON array or object, as is required by "JSON text" in the JSON MIME type specification.</para>
      <para>XDI processors SHOULD accept non-canonical JSON values as input.</para>
      <para>XDI processors MAY output partly, fully, or not at all canonicalized versions of JSON values that clients have input, for example by removing spaces.</para>
      <para>XDI processors SHOULD fully canonicalize JSON values that are results and not user input.</para>
      <para>Canonical form includes:</para>
      <para>No unnecessary whitespace</para>
      <para>Nonzero numbers have no leading zeros or preceding + sign in either fraction or exponent</para>
      <para>An exponent is preceded by uppercase E</para>
      <para>Hex in \u character escapes should be lowercase</para>
<programlisting>
json-value  = json-object / json-array / json-string / json-number / "true" / "false" / "null"
json-object = "{" [ json-string ":" json-value *( "," json-string ":" json-value ) ] "}"
json-array  = "[" [                 json-value *( ","                 json-value ) ] "]"
json-string = QUOTE *( " " / "!" / %x23-5B  / %x5D-EFFFD / json-escape )    QUOTE
json-escape = "\"    ("\" / "/" / "b" / "f" / "n" / "r" / "t" / QUOTE / ( "u" 4HEX ) )
json-number = ( "0" / [ "-" ] noleading ) [ "." notrailing ] [ "E" [ "-" ] noleading ]
noleading   = %x31-39 *DIGIT
notrailing  = *DIGIT  %x31-39
</programlisting>
    </section>


  </section>
  <section><title>Serialization Grammars</title>
      <para>The previous sections used these symbols as generic delimiters; a serialization is defined by how these delimiters are concretely represented.</para>
      <para>STMTSL,R,N: Before, after, and between items of, a list of statements</para>
      <para>OBJSL,R,N:  Before, after, and between items of, a list of objects, for serializations allowing multiple objects for one subject/predicate</para>
      <para>STMTL,R:    Before and after a statement</para>
      <para>S-P, P-O:   Between subject, predicate, and object of a statement</para>
      <para>C-I:        Between a context symbol and the following identifier</para>

    <section><title>Display Format Statement Serialization Grammar</title>
      <para>XDI Display Format is a compact human-readable representation of XDI paths and statements using a minimum of delimiters, but is not in a standard data interchange format such as JSON. Each statement is on a separate line, and the subject/predicate/object of a triple are separated by the slash /.</para>
      <para>Multiline XDI Display Format allows a subject/predicate pair to by followed by multiple objects, indicated by indentation.</para>
<programlisting>
STMTSL = ""
STMTSN = ENDLINE
STMTSR = ""
OBJSL  = ""
OBJSN  = ENDLINE %x09
OBJSR  = ""
STMTL  = ""
STMTR  = ""
S-P    = "/"
P-O    = "/"
C-I    = ""
</programlisting>
        <para>Example:</para>
<screen>
[=]!:uuid:1111+profiles[&lt;+work&gt;]&lt;!:uuid:5555&gt;/$ref/[=]!:uuid:1111+first&lt;+name&gt;
</screen>
    </section>

    <section><title>Flat JSON Statement Serialization Grammar</title>
      <para>The JSON serializations may have extra whitespace when prettyprinted, but XDI processors SHOULD generate JSON with no extraneous whitespace, as wire format in normal operation.</para>
      <para>In the Flat JSON statement list serialization, the statement list is a JSON object of key-value pairs where each key is a subject/predicate pair (strings joined by a slash) and each value is a JSON array of objects; except in the case of the value statement where the value is simply the value.</para>
<programlisting>
STMTSL = "{" 
STMTSN = QUOTE "," QUOTE
STMTSR = "}"
OBJSL  = "["
OBJSN  = ","
OBJSR  = "]"
STMTL  = "{" QUOTE
STMTR  = QUOTE "}"
S-P    = "/"
P-O    = QUOTE ":" QUOTE
C-I    = ""
</programlisting>
        <para>Example: (prettyprinted with whitespace that is not significant)</para>
<screen>
{
  "[=]!:uuid:1111+profiles[&lt;+work&gt;]&lt;!:uuid:5555&gt;/$ref": [
    "[=]!:uuid:1111+first&lt;+name&gt;"
  ]
}
</screen>
    </section>

    <section><title>Parsed JSON Statement Serialization Grammar</title>
      <para>In the Parsed JSON statement list serialization, the statement list is a JSON array, of statements which are each a JSON array of 3 addresses, which are each JSON array of arcs, each of which is a JSON object with context symbol (or left delimiter) as key and identifier as value. When there are multiple symbols and operators, the first symbol is a key, whose value is a JSON object representing the remainder of the arc.</para>
<programlisting>
STMTSL = "["
STMTSN = QUOTE "," QUOTE
STMTSR = "]"
OBJSL  = "["
OBJSN  = ","
OBJSR  = "]"
STMTL  = "[" QUOTE
STMTR  = QUOTE "]"
S-P    = QUOTE "," QUOTE
P-O    = QUOTE "," QUOTE
C-I    = QUOTE "," QUOTE
</programlisting>
        <para>Example: (prettyprinted with whitespace that is not significant)</para>
<screen>
[
  [
    [
      {
        "[": "="
      },
      {
        "!": ":uuid:1111"
      },
      {
        "+": "profiles"
      },
      {
        "[": {
          "&lt;": {
            "+": "work"
          }
        }
      },
      {
        "&lt;": {
          "!": ":uuid:5555"
        }
      }
    ],
    {
      "$": "ref"
    },
    [
      {
        "[": "="
      },
      {
        "!": ":uuid:1111"
      },
      {
        "+": "first"
      },
      {
        "&lt;": {
          "+": "name"
        }
      }
    ]
  ]
]


</screen>
<sidebar><title>A Sidebar</title>
<para>
Sidebar content.
</para>
</sidebar>
    </section>

    <section><title>Graph Tree Serialization Grammar</title>
      <para>Unlike the previous serializations, this directly represents a (sub)graph, rather than a list of statements that build up a (sub)graph; therefore it cannot be constructed from the statement grammar simply by plugging in delimiters.</para>
      <para>Strings represent single arcs between context nodes, which obviates the need for long addresses; except in the case of the object of a relational statement, which is still represented by a single address string.</para>
      <para>A context node is represented as a JSON object, whose keys are the labels of the outgoing arcs, and whose values are the target nodes, either more context nodes, or terminal value nodes which are objects with key "&amp;". Relational statements are in a list under the special key "/"..</para>
<programlisting>
node            = context-node / literal-node
context-node    = "{" node *( "," node ) "}"
literal-node    = "{" QUOTE "&amp;" QUOTE ":" json-value "}"
arc             = contextual-arc / relational-arcs
contextual-arc  = QUOTE singleton QUOTE ":" context-node
relational-arcs = "{" QUOTE "/" QUOTE ":" relation *( "," relation ) "}"
relation        = "{" QUOTE pred QUOTE ":" "[" xdi-address *( "," xdi-address ) "]" "}"
</programlisting>
        <para>Example:</para>
<screen>
{
  "[=]": {
    "!:uuid:1111": {
      "+profiles": {
        "[&lt;+work&gt;]": {
          "&lt;!:uuid:5555&gt;": {
            "/": {
              "$ref": [
                "[=]!:uuid:1111+first&lt;+name&gt;"
              ]
            }
          }
        }
      },
      "+first": {}
    }
  }
}
</screen>
    </section>



  </section>
  <section><title>Serialization</title>
    <para>Serialization</para>
    <section><title>Formats</title>
      <para>Formats</para></section>
    <section><title>Rules</title>
      <para>Rules</para></section>
  </section>
  <section><title>Addressing Rules</title>
    <para>Addressing Rules</para>
  </section>
  <section><title>XDI Identifier Schemes</title>
    <para>Schemes indicate certain classes of identifiers in canonical form. Schemes are signaled by a prefix between colons, preceding the identifier.</para>
    <section><title>UUID</title>
      <para>Universally Unique Identifier</para></section>
    <section><title>IPv6 number</title>
      <para>This is a single IPv6 number, in unabbreviated form.</para></section>
    <section><title>SHA-2 hash</title>
      <para>SHA-256, SHA-384, and SHA-512</para></section>
    <section><title>Extensibility</title>
      <para>Extensibility</para></section>
  </section>

<appendix id="s.acknowledgements" role="non-normative">
  <title>Acknowledgements</title>

  <para>This specification was written with the generous and appreciated assistance of</para>
</appendix>
  
<appendix id="a.dollarwords" role="non-normative">
  <title>Dollar Words</title>
  
  <para>This appendix contains formal definitions of the XDI dollar words introduced by this specification.</para>
</appendix>
  
<appendix id="a.examples" role="non-normative">
  <title>Examples</title>
  
  <para>This appendix contains XDI core examples.</para>
</appendix>

</article>
